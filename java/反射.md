# 反射

------



## 通过案例体会反射的好处

案例：美团外卖 —  付款 — 要么支付宝支付 要么微信支付

![image-20221029104823328](/Users/rain/Library/Application Support/typora-user-images/image-20221029104823328.png)

代码演示：

```java
public class WeChat implements Mtwm{
    @Override
    public void payOnline() {
        //具体实现微信支付的功能
        System.out.println("正在使用微信支付");
    }
}
```

```java
public class AliPay implements Mtwm{
    @Override
    public void payOnline() {
        System.out.println("正在使用支付宝支付！");
    }
}
```

```java
public class BankPay implements Mtwm{
    @Override
    public void payOnline() {
        System.out.println("正在使用银行支付！");
    }
}
```



```java
package com.msb.test01;

/**
 * @ClassName: Test
 * @Author: rain
 * @Date: 2022/10/27 - 10 - 27 - 20:37
 * @Description:
 * @Version: 1.0
 */


public class Test {
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) {
        String str = "微信";

        if("微信".equals(str)){
            pay(new WeChat());
        }

        if("支付宝".equals(str)){
            pay(new AliPay());
        }
        if("银行".equals(str)){
            pay(new BankPay());
        }

    }

    public static void pay(AliPay ap){
        ap.payOnline();
    }
    public static void pay(WeChat wc){
        wc.payOnline();
    }
    public static void pay(BankPay bp){
        bp.payOnline();
    }
}
```

为了提供代码的扩展性 — 使用多态

```java
package com.msb.test01;

public class Test {
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) {
        String str = "微信";

        if("微信".equals(str)){
            pay(new WeChat());
        }

        if("支付宝".equals(str)){
            pay(new AliPay());
        }
        if("银行".equals(str)){
            pay(new BankPay());
        }

    }

    //方法的形成是接口，具体传入的是接口的实现类的对象 --- 多态的一种形式
    public static void pay(Mtwm m) {
        m.payOnline();
    }
}
```

多态可以提供扩展性，但是没有达到最好，上面的分支，还需要手动添加或删除

处理的最后办法是加入反射机制：

利用反射实现上述功能

```java
package com.msb.test01;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

/**
 * @ClassName: Demo
 * @Author: rain
 * @Date: 2022/10/27 - 10 - 27 - 20:30
 * @Description:  引入反射机制
 * @Version: 1.0
 */


public class Demo {
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws Exception{
        //定义一个字符串，用来模拟前台的支付方式
        String str = "com.msb.test01.AliPay"; //字符串： 实际上就是微信类的全限定路径

        //下面的代码就是利用反射：
        Class cls = Class.forName(str);
        Object o = cls.newInstance();
        Method m = cls.getMethod("payOnline");
        m.invoke(o);


    }
}
```









## 通过概念在体会反射

```
Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能成为Java语言的发射机制。

在编译后产生字节码文件的时候，类加载器子系统通过二进制字节流，负责从文件系统加载class文件。在执行程序(java.exe)时候，将字节码文件读入JVM中-- 这个过程叫做类的加载。然后在内存中对应创建一个java.lang.class对象 -- 这个对象会被放入字节码信息中，这个class对象，就对应加载那个字节码信息，这个对象被作为程序访问方法区中的这个类的各种数据的外部接口。
所以：我们通过这个对象看到类的结构，这个对象好像一个镜子，通过镜子看到类的各种信息，我们形象的称之为反射。这种"看透"class的能力，被称为 introspection(内省、内观、反省)。Reflection和introspection是常被并提的两个术语。

说明：在运行期间，如果我们要产生某个类的对象，java虚拟机(JVM)会坚持该类型的class对象是否被已加载。如果没有被加载，JVM会根据类的名称找到.class文件并加载它。一旦某个类的class对象已被加载到内存，就可以用它来产生该类型的所有对象。
```









## Class类的理解

![image-20221027211919582](/Users/rain/Library/Application Support/typora-user-images/image-20221027211919582.png)





## 提供丰富的类



```java
package com.msb.test02;

import java.sql.SQLOutput;

/**
 * @ClassName: Person
 * @Author: rain
 * @Date: 2022/10/27 - 10 - 27 - 21:21
 * @Description:
 * @Version: 1.0
 */


//作为一个父类
public class Person {
    //属性
    private int age;
    public String name;

    //方法
    private void eat(){
        System.out.println("Person -- eat");
    }
    public void sleep(){
        System.out.println("Person --- sleep");
    }
}
```



```java
package com.msb.test02;

import java.util.HashSet;

/**
 * @ClassName: Student
 * @Author: rain
 * @Date: 2022/10/27 - 10 - 27 - 21:24
 * @Description:
 * @Version: 1.0
 */

//作为子类
public class Student extends Person{
    //属性
    private int sno;
    double height;
    protected double weight;
    public double score;

    //方法
    public String showInfo(){
        return "我是一名学生";
    }

    private void work(){
        System.out.println("好好工作，挣钱");
    }


    //构造器
    public Student() {
    }

    private Student(int sno) {
        this.sno = sno;
    }

    Student(int sno,double height, double weight) {
        this.sno = sno;
        this.height = height;
        this.weight = weight;
    }
}
```



## 获取字节码信息的四种形式



```java
package com.msb.test02;

/**
 * @ClassName: Test02
 * @Author: rain
 * @Date: 2022/10/28 - 10 - 28 - 13:46
 * @Description:
 * @Version: 1.0
 */


public class Test02 {
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws ClassNotFoundException {
        //案例：以Person的字节码信息为案例
        //方式1:
        Person p1 = new Person();
        Class c1 = p1.getClass();
        System.out.println(c1);

        //方式2：通过内置class属性：
        Class c2 = Person.class;
        System.out.println(c2);
        System.out.println(c1 == c2);
//方式1 和 方式2 不常用

        //方式3  -- 用的最多，调用class 类提供的静态方法forName
        Class c3 = Class.forName("com.msb.test02.Person");
        System.out.println(c3);

        //方式4:利用类的加载器
        ClassLoader loader = Test02.class.getClassLoader();
        Class c4 = loader.loadClass("com.msb.test02.Person");
        System.out.println(c4);
        //方式5
        //
    }
}
```





## 可以作为Class类的实例的种类

Class类的具体的实例：

（1）类：外部类，内部类

（2）接口：

（3）注解

（4）数组

（5）数据类型

（6）void

```java
package com.msb.test02;

import java.sql.SQLOutput;

/**
 * @ClassName: Demo
 * @Author: rain
 * @Date: 2022/10/28 - 10 - 28 - 14:25
 * @Description:
 * @Version: 1.0
 */


public class Demo {
    /*
    Class类的具体的实例：

    （1）类：外部类，内部类

    （2）接口：

    （3）注解

    （4）数组

    （5）数据类型

    （6）void
     */
//这是一个main方法，是程序的入口：
    public static void main(String[] args) {

        Class c1 = Person.class;
        Class c2 = Comparable.class;
        Class c3 = Override.class;

        int[] arr1 = {1,2,3};
        Class c4 = arr1.getClass();
        int[] arr2 = {5,6,7};
        Class c5 = arr2.getClass();
        System.out.println(c4==c5);  //结果：True，同一个维度，同一个元素类型，得到的字节码就是一个

        Class c6 = int.class;
        Class c7 = void.class;

        System.out.println(c6==c7); //false
    }
}
```



## 获取运行时类的完整结构

### 补充上面类提供的丰富的类

```java
package com.msb.test03;

/**
 * @ClassName: Student
 * @Author: rain
 * @Date: 2022/10/28 - 10 - 28 - 16:27
 * @Description:
 * @Version: 1.0
 */


//Student作为子类
@MyAnnotation(value = "hello")
public class Student extends Person implements MyInterface{
    //属性:
    private int sno;  //学号
    double height;    //身高
    protected double weight; //体重
    public double score;  //成绩

    //方法：
    @MyAnnotation(value = "himethod")
    public String showInfo(){
        return "我是一个学生";
    }

    public String showInfo(int a){
        return "重载方法 -- 我是一个学生";
    }

    private void work(){
        System.out.println("我以后会找工作 -- 111");
    }

    void happy(){
        System.out.println("开心");
    }

    protected int geySno(){
        return sno;
    }

    //构造器

    public Student(int sno) {
        this.sno = sno;
    }

    public Student(int sno, double height, double weight) {
        this.sno = sno;
        this.height = height;
        this.weight = weight;
    }

    public Student(int sno, double height, double weight, double score) {
        this.sno = sno;
    }


    @Override
    @MyAnnotation(value = "helloMethod")
    public void myMethod(){
        System.out.println("我重写了抽象方法！");
    }

    @Override
    public String toString() {
        return "Student{" +
                "sno=" + sno +
                ", height=" + height +
                ", weight=" + weight +
                ", score=" + score +
                '}';
    }
}
```



```java
package com.msb.test03;

import java.io.Serializable;

/**
 * @ClassName: Person
 * @Author: rain
 * @Date: 2022/10/28 - 10 - 28 - 16:27
 * @Description:
 * @Version: 1.0
 */

//作为一个父类
public class Person implements Serializable {
    //属性
    private int age;
    public String name;

    //方法
    private void eat(){
        System.out.println("Person--eat");
    }
    public void sleep(){
        System.out.println("Person--sleep");
    }
}
```



```java
package com.msb.test03;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import static java.lang.annotation.ElementType.*;

/**
 * @ClassName: MyAnnotation
 * @Author: rain
 * @Date: 2022/10/28 - 10 - 28 - 16:53
 * @Description:
 * @Version: 1.0
 */

/*
@Target: 定义当前注解能够修饰程序中的哪些元素
@Retention:定义注解的声明周期
 */

@Target({TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE})
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation {
    String value();//属性
}
```



```java
package com.msb.test03;

/**
 * @ClassName: MyInterface
 * @Author: rain
 * @Date: 2022/10/28 - 10 - 28 - 17:01
 * @Description:
 * @Version: 1.0
 */

public interface MyInterface {
    void myMethod();
}
```





### 获取构造器并且创建对象

```java
package com.msb.test03;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;

/**
 * @ClassName: Test01
 * @Author: rain
 * @Date: 2022/10/28 - 10 - 28 - 17:09
 * @Description: 通过字节码信息获取类属性方法
 * @Version: 1.0
 */


public class Test01 {
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
        //获取字节码信息
        Class cls = Student.class;

        //通过字节码信息可以获取构造器:
        //通过getConstructors只能获取当前运行时类的被public修饰的构造器
        Constructor[] c1 = cls.getConstructors();
        for(Constructor c : c1){
            System.out.println(c);
        }
        //通过getDeclaredConstructors可以获取运行时类全部修饰符的构造器
        System.out.println("----------");

        Constructor[] c2 = cls.getDeclaredConstructors();
        for(Constructor c : c2){
            System.out.println(c);
        }

        System.out.println("----------");

        //获取空的构造器：
        Constructor con1 = cls.getConstructor();
        System.out.println(con1);

        //获取两个参数的构造器
        Constructor con2 = cls.getConstructor(int.class,double.class);
        System.out.println(con2);

        //得到一个参数的构造器，并且是private修饰的
        Constructor con3 = cls.getDeclaredConstructor(int.class);
        System.out.println(con3);

      	//通过构造器，创建一个对象
        Object o1 = con2.newInstance(23,198.5);
        System.out.println(o1);
    }
}
```



### 获取属性和给属性赋值

```java
package com.msb.test03;

import java.lang.ref.Cleaner;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;

/**
 * @ClassName: Test02
 * @Author: rain
 * @Date: 2022/10/28 - 10 - 28 - 19:05
 * @Description:
 * @Version: 1.0
 */


public class Test02 {
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws Exception{
        //获取运行时类的字节码信息：
        Class cls = Class.forName("com.msb.test03.Student");
        //获取属性
        //getFields:获取运行时父类和类中被public修饰的属性
        Field[] fields = cls.getFields();
        for(Field field : fields){
            System.out.println(field);
        }
        System.out.println("----------------------");

        //getDeclaredFields:获取所有的属性
        Field[] declaredFields = cls.getDeclaredFields();
        for (Field declaredField : declaredFields) {
            System.out.println(declaredField);
        }
        System.out.println("----------------------");

        //获取指定的属性
        Field score = cls.getField("score");
        System.out.println(score);
        Field sno = cls.getDeclaredField("sno");
        System.out.println(sno);
        System.out.println("----------------------");

        //属性的具体结构：
        //获取修饰符
        System.out.println(Modifier.toString(sno.getModifiers()));

        //获取属性的数据类型
        Class clazz = sno.getType();
        System.out.println(clazz.getName());

        //获取属性的名字
        String name = sno.getName();
        System.out.println(name);
        System.out.println("----------------------");

        //给属性赋值：
        Field sco = cls.getField("score");
        Object obj = cls.newInstance();
        sco.set(obj,98); //给obj这个对象的score属性设置具体的值，这个值为98
        System.out.println(obj);
    }
}
```



### 获取方法和调用方法

```java
package com.msb.test03;

import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;

/**
 * @ClassName: Test03
 * @Author: rain
 * @Date: 2022/10/28 - 10 - 28 - 20:19
 * @Description: 获取方法和调用方法
 * @Version: 1.0
 */


public class Test03 {
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws Exception {
        //获取字节码信息
        Class cls = Student.class;
        //获取方法：
        //getMethods:获取运行时类和所有父类的方法
        Method[] methods = cls.getMethods();
        for(Method m : methods){
            System.out.println(m);
        }
        System.out.println("----------------------");

        //getDeclaredMethods:获取运行时类的所有方法
        Method[] methods2 = cls.getDeclaredMethods();
        for (Method m : methods2) {
            System.out.println(m);
        }

        System.out.println("----------------------");
//  获取指定方法：
        Method showInfo1  = cls.getMethod("showInfo", int.class);
        System.out.println(showInfo1);
        Method showInfo2  = cls.getMethod("showInfo");
        System.out.println(showInfo2);
        Method work = cls.getDeclaredMethod("work",int.class);
        System.out.println(work);
        System.out.println("----------------------");

        //获取方法的具体结构：
        /*
        @注解
        修饰符 返回值类型 方法名（参数列表） throws xx
         */
        //名字
        System.out.println(work.getName());
        //修饰符
        int modifers = work.getModifiers();
        System.out.println(Modifier.toString(modifers));
        //返回值
        System.out.println(work.getReturnType());
        //参数列表：
        Class[] params = work.getParameterTypes();
        for (Class param : params){
            System.out.println(param);
        }
        System.out.println("----------------------");

        //获取注解：
        Method me = cls.getMethod("myMethod");
        Annotation[] annotations = me.getAnnotations();
        for (Annotation a : annotations) {
            System.out.println(a);
        }
        //获取异常
        Class[] exceptions = me.getExceptionTypes();
        for (Class c :exceptions) {
            System.out.println(c);
        }

        //调用方法：
        Object o = cls.newInstance();
        me.invoke(o); //调用o对象的method方法

        //调用一个参数的重载方法
        System.out.println(showInfo1.invoke(o,12));;
    }
}
```



### 获取类的接口、所在包、注解 

```java
package com.msb.test03;

import java.lang.annotation.Annotation;

/**
 * @ClassName: Test04
 * @Author: rain
 * @Date: 2022/10/29 - 10 - 29 - 09:56
 * @Description:
 * @Version: 1.0
 */


public class Test04 {
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) {
        //获取字节码信息
        Class cls = Student.class;
        //获取运行时类的接口：
        Class[] interfaces = cls.getInterfaces();
        for(Class c :interfaces){
            System.out.println(c);
        }
        //得到父类的接口
        //先得到父类的字节码信息
        Class superclass = cls.getSuperclass();
        Class[] inye = superclass.getInterfaces();
        for (Class c : inye) {
            System.out.println(c);
        }

        //获取运行时类所在的包
        Package pkg = cls.getPackage();
        System.out.println(pkg);
        System.out.println(pkg.getName());

        //获取运行时类的注解：
        Annotation[] annotations = cls.getAnnotations();
        for (Annotation annotation : annotations) {
            System.out.println(annotation);
        }
    }
}
```



### 关于反射的面试题

【1】问题1: 创建Person的对象，以后用new Person()创建，还是用反射创建？

通过new创建对象的效率比较高。通过反射时，先找查找类资源，使用[类加载](https://so.csdn.net/so/search?q=类加载&spm=1001.2101.3001.7020)器创建，过程比较繁琐，所以效率较低



new属于静态编译
反射属于动态编译，意思就说只有到运行时才会去获得该对象的实例,Spring就是使用的反射

静态编译就是在编译的时候把你所有的模块都编译进exe里去。

动态编译就不一样了，编译的时候那些模块都没有编译进去，一般情况下可以把那些模块都编译成dll，这样启动程序（初始化）的时候这些模块不会被加载，而是在运行的时候，用到那个模块就调用哪个模块

1、静态编译相当于把所有需要的东西都在初始化的时候加载了，如果程序一大，就很有可能会跑得慢。

2、动态编译，在编译的时候，需要的模块都没有编译进去，启动程序的时候，模块不会被加载而是在运行的时候，需要哪个模块就调用哪个模块。

上面的过程告诉我们，我们如果用new，那么我们要创建的类都是已经“写死”在.class文件里面了，我们无法控制JVM帮我们加载类的这一项工作。

但是如果我们用反射创建类对象，我们是相当于亲自“指导”JVM，我们“按需加载”.class文件，如果内存里面没有这个类的.class文件，那么我们用Class.forName（）去叫类加载器帮忙加载就行了，而不是把程序停下来，再打一段代码，再让类加载器进行加载，从而体现出了Java的“动态性”



【2】问题2: 反射是否破坏了面向对象的封装性？

什么是封装？
  答：程序的封装指的是利用各种权限修饰符（private、public、protected、default）来对类中的成员的访问权限加以限制，强制用户使用该类的时候必须遵守这个权限限制，只能按照类中设计的访问接口进行访问。其他部分就像是用罩子封装起来一样，用户是看不见的。
  举个现实中的例子：就像生活中的电脑一样，电脑是在工厂经过一系列组装，封装成了我们看到的样子。只给我们留下了有限的接口如：屏幕，键盘，usb接口等等，用户只能使用这些接口访问笔记本电脑里的数据，而不能直接从内存条或者硬盘上访问数据。这就是现实生活中的一种封装。

反射是否破坏了面向对象的封装性？
  答：反射并没有破坏面向对象的封装性。因为通过反射机制获取到的带权限修饰符的方法和属性都依然遵照权限修饰符限定的访问方式。
  除非调用setAccessible(true)方法来抑制java访问权限检查，从而达到可以随意访问的效果。但是利用setAccessible(true)是一种暴力方式，不安全。开发人员一般不会用这种方式损害自己代码的封装性。
  举个例子：就像现实生活中的电脑，是在工厂经过一系列组装，封装成了我们看到的样子。只给我们留下了有限的接口如：屏幕，键盘，usb接口等等，用户只能使用这些接口访问笔记本电脑里的数据，而不能直接从内存条或者硬盘上访问数据。但是，电脑维修的时候，也可以用暴力的方式拆开电脑的外壳，从而看到电脑的内部结构。
  同样的道理setAccessible(true)就是java反射中的一种最终的暴力手段，但是这并不破坏Java的封装性。就像电脑可以被暴力拆解，但是不影响电脑是一个被封装起来供用户使用的数码产品。

























# 一、回顾：什么是反射？

反射 (Reflection) 是 Java 的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。

Oracle 官方对反射的解释是：

> Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.
> The API accommodates applications that need access to either the public members of a target object (based on its runtime class) or the members declared by a given class. It also allows programs to suppress default reflective access control.

简而言之，通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。程序中一般的对象的类型都是在编译期就确定下来的，而 Java 反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。

反射的核心是 JVM 在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。

Java 反射主要提供以下功能：

- 在运行时判断任意一个对象所属的类；
- 在运行时构造任意一个类的对象；
- 在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；
- 在运行时调用任意一个对象的方法

重点：**是运行时而不是编译时**

# 二、反射的主要用途

很多人都认为反射在实际的 Java 开发应用中并不广泛，其实不然。当我们在使用 IDE(如 Eclipse，IDEA)时，当我们输入一个对象或类并想调用它的属性或方法时，一按点号，编译器就会自动列出它的属性或方法，这里就会用到反射。

**反射最重要的用途就是开发各种通用框架。**很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 Bean），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射，运行时动态加载需要加载的对象。

举一个例子，在运用 Struts 2 框架的开发中我们一般会在 `struts.xml` 里去配置 `Action`，比如：

```
<action name="login"
               class="org.ScZyhSoft.test.action.SimpleLoginAction"
               method="execute">
           <result>/shop/shop-index.jsp</result>
           <result name="error">login.jsp</result>
       </action>
```

配置文件与 `Action` 建立了一种映射关系，当 View 层发出请求时，请求会被 `StrutsPrepareAndExecuteFilter` 拦截，然后 `StrutsPrepareAndExecuteFilter` 会去动态地创建 Action 实例。比如我们请求 `login.action`，那么 `StrutsPrepareAndExecuteFilter`就会去解析struts.xml文件，检索action中name为login的Action，并根据class属性创建SimpleLoginAction实例，并用invoke方法来调用execute方法，这个过程离不开反射。

对与框架开发人员来说，反射虽小但作用非常大，它是各种容器实现的核心。而对于一般的开发者来说，不深入框架开发则用反射用的就会少一点，不过了解一下框架的底层机制有助于丰富自己的编程思想，也是很有益的。

# 三、反射的基本运用

上面我们提到了反射可以用于判断任意对象所属的类，获得 Class 对象，构造任意一个对象以及调用一个对象。这里我们介绍一下基本反射功能的使用和实现(反射相关的类一般都在 java.lang.relfect 包里)。

## 1、获得 Class 对象

方法有三种：

(1) 使用 Class 类的 `forName` 静态方法:

```
 public static Class<?> forName(String className)
​``` 

比如在 JDBC 开发中常用此方法加载数据库驱动:

​```java
 Class.forName(driver);
```

(2)直接获取某一个对象的 class，比如:

```
Class<?> klass = int.class;
Class<?> classInt = Integer.TYPE;
```

(3)调用某个对象的 `getClass()` 方法，比如:

```
StringBuilder str = new StringBuilder("123");
Class<?> klass = str.getClass();
```

## 2、判断是否为某个类的实例

一般地，我们用 `instanceof` 关键字来判断是否为某个类的实例。同时我们也可以借助反射中 Class 对象的 `isInstance()` 方法来判断是否为某个类的实例，它是一个 native 方法：

```
public native boolean isInstance(Object obj);
```

## 3、创建实例

通过反射来生成对象主要有两种方式。

- 使用Class对象的newInstance()方法来创建Class对象对应类的实例。

```
Class<?> c = String.class;
Object str = c.newInstance();
```

- 先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建实例。这种方法可以用指定的构造器构造类的实例。

```
//获取String所对应的Class对象
Class<?> c = String.class;
//获取String类带一个String参数的构造器
Constructor constructor = c.getConstructor(String.class);
//根据构造器创建实例
Object obj = constructor.newInstance("23333");
System.out.println(obj);
```

## 4、获取方法

获取某个Class对象的方法集合，主要有以下几个方法：

- `getDeclaredMethods` 方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。

```
public Method[] getDeclaredMethods() throws SecurityException
```

- `getMethods` 方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。

```
public Method[] getMethods() throws SecurityException
```

- `getMethod` 方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象。

```
public Method getMethod(String name, Class<?>... parameterTypes)
```

只是这样描述的话可能难以理解，我们用例子来理解这三个方法：

```
package org.ScZyhSoft.common;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class test1 {
	public static void test() throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {
	        Class<?> c = methodClass.class;
	        Object object = c.newInstance();
	        Method[] methods = c.getMethods();
	        Method[] declaredMethods = c.getDeclaredMethods();
	        //获取methodClass类的add方法
	        Method method = c.getMethod("add", int.class, int.class);
	        //getMethods()方法获取的所有方法
	        System.out.println("getMethods获取的方法：");
	        for(Method m:methods)
	            System.out.println(m);
	        //getDeclaredMethods()方法获取的所有方法
	        System.out.println("getDeclaredMethods获取的方法：");
	        for(Method m:declaredMethods)
	            System.out.println(m);
	    }
    }
class methodClass {

    public final int fuck = 3;
    public int add(int a,int b) {
        return a+b;
    }
    public int sub(int a,int b) {
        return a+b;
    }
}
```

程序运行的结果如下:

```
getMethods获取的方法：
public int org.ScZyhSoft.common.methodClass.add(int,int)
public int org.ScZyhSoft.common.methodClass.sub(int,int)
public final void java.lang.Object.wait() throws java.lang.InterruptedException
public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException
public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException
public boolean java.lang.Object.equals(java.lang.Object)
public java.lang.String java.lang.Object.toString()
public native int java.lang.Object.hashCode()
public final native java.lang.Class java.lang.Object.getClass()
public final native void java.lang.Object.notify()
public final native void java.lang.Object.notifyAll()
getDeclaredMethods获取的方法：
public int org.ScZyhSoft.common.methodClass.add(int,int)
public int org.ScZyhSoft.common.methodClass.sub(int,int)
```

可以看到，通过 `getMethods()` 获取的方法可以获取到父类的方法,比如 java.lang.Object 下定义的各个方法。

## 5、获取构造器信息

获取类构造器的用法与上述获取方法的用法类似。主要是通过Class类的getConstructor方法得到Constructor类的一个实例，而Constructor类有一个newInstance方法可以创建一个对象实例:

```
public T newInstance(Object ... initargs)
```

此方法可以根据传入的参数来调用对应的Constructor创建对象实例。

## 6、获取类的成员变量（字段）信息

主要是这几个方法，在此不再赘述：

- `getFiled`：访问公有的成员变量
- `getDeclaredField`：所有已声明的成员变量，但不能得到其父类的成员变量

`getFileds` 和 `getDeclaredFields` 方法用法同上（参照 Method）。

## 7、调用方法

当我们从类中获取了一个方法后，我们就可以用 `invoke()` 方法来调用这个方法。`invoke` 方法的原型为:

```
public Object invoke(Object obj, Object... args)
        throws IllegalAccessException, IllegalArgumentException,
           InvocationTargetException
```

下面是一个实例：

```
public class test1 {

    public static void main(String[] args) throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {
        Class<?> klass = methodClass.class;
        //创建methodClass的实例
        Object obj = klass.newInstance();
        //获取methodClass类的add方法
        Method method = klass.getMethod("add",int.class,int.class);
        //调用method对应的方法 => add(1,4)
        Object result = method.invoke(obj,1,4);
        System.out.println(result);
    }

}

class methodClass {

    public final int fuck = 3;
    public int add(int a,int b) {
        return a+b;
    }
    public int sub(int a,int b) {
        return a+b;
    }
}
```

关于 `invoke` 方法的详解，后面我会专门写一篇文章来深入解析 invoke 的过程。

## 8、利用反射创建数组

数组在Java里是比较特殊的一种类型，它可以赋值给一个Object Reference。下面我们看一看利用反射创建数组的例子：

```
public static void testArray() throws ClassNotFoundException {
        Class<?> cls = Class.forName("java.lang.String");
        Object array = Array.newInstance(cls,25);
        //往数组里添加内容
        Array.set(array,0,"hello");
        Array.set(array,1,"Java");
        Array.set(array,2,"fuck");
        Array.set(array,3,"Scala");
        Array.set(array,4,"Clojure");
        //获取某一项的内容
        System.out.println(Array.get(array,3));
    }
```

其中的Array类为java.lang.reflect.Array类。我们通过Array.newInstance()创建数组对象，它的原型是:

```
public static Object newInstance(Class<?> componentType, int length)
        throws NegativeArraySizeException {
        return newArray(componentType, length);
    }
```

而 `newArray` 方法是一个 native 方法，它在 HotSpot JVM 里的具体实现我们后边再研究，这里先把源码贴出来：

```
private static native Object newArray(Class<?> componentType, int length)
        throws NegativeArraySizeException;
```

源码目录：`openjdk\hotspot\src\share\vm\runtime\reflection.cpp`

```
arrayOop Reflection::reflect_new_array(oop element_mirror, jint length, TRAPS) {
  if (element_mirror == NULL) {
    THROW_0(vmSymbols::java_lang_NullPointerException());
  }
  if (length < 0) {
    THROW_0(vmSymbols::java_lang_NegativeArraySizeException());
  }
  if (java_lang_Class::is_primitive(element_mirror)) {
    Klass* tak = basic_type_mirror_to_arrayklass(element_mirror, CHECK_NULL);
    return TypeArrayKlass::cast(tak)->allocate(length, THREAD);
  } else {
    Klass* k = java_lang_Class::as_Klass(element_mirror);
    if (k->oop_is_array() && ArrayKlass::cast(k)->dimension() >= MAX_DIM) {
      THROW_0(vmSymbols::java_lang_IllegalArgumentException());
    }
    return oopFactory::new_objArray(k, length, THREAD);
  }
}
```

另外，Array 类的 `set` 和 `get` 方法都为 native 方法，在 HotSpot JVM 里分别对应 `Reflection::array_set` 和 `Reflection::array_get` 方法，这里就不详细解析了。

# 四、反射的一些注意事项

由于反射会额外消耗一定的系统资源，因此如果不需要动态地创建一个对象，那么就不需要用反射。

另外，反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。

# 引入

即使没有学过反射，大家也一定会见过invoke方法。因为很多方法调用都是靠invoke方法，所以很多异常的抛出都会定位到invoke方法，比如下面的情形大家会很熟悉:

```
java.lang.NullPointerException
  at ......
  at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
  at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
  at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
  at java.lang.reflect.Method.invoke(Method.java:497)
```



大家在看到异常抛出时，除了想要排除Bug，是不是同时也对这个神秘的invoke乃至invoke0方法有一些好奇呢？我们下面就来揭开它神秘的面纱，探寻底层的机制。

# 浅析invoke过程

上一篇文章我们讲过，invoke方法用来在运行时动态地调用某个实例的方法。它的实现如下：

```
@CallerSensitive
public Object invoke(Object obj, Object... args)
    throws IllegalAccessException, IllegalArgumentException,
       InvocationTargetException
{
    if (!override) {
        if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {
            Class<?> caller = Reflection.getCallerClass();
            checkAccess(caller, clazz, obj, modifiers);
        }
    }
    MethodAccessor ma = methodAccessor;             // read volatile
    if (ma == null) {
        ma = acquireMethodAccessor();
    }
    return ma.invoke(obj, args);
}
```



我们根据invoke方法的实现，将其分为以下几步：

## 1、权限检查

invoke方法会首先检查AccessibleObject的override属性的值。AccessibleObject 类是 Field、Method 和 Constructor 对象的基类。它提供了将反射的对象标记为在使用时取消默认 Java 语言访问控制检查的能力。
override的值默认是false,表示需要权限调用规则，调用方法时需要检查权限;我们也可以用setAccessible方法设置为true,若override的值为true，表示忽略权限规则，调用方法时无需检查权限（也就是说可以调用任意的private方法，违反了封装）。
如果override属性为默认值false，则进行进一步的权限检查：
（1）首先用Reflection.quickCheckMemberAccess(clazz, modifiers)方法检查方法是否为public，如果是的话跳出本步；如果不是public方法，那么用Reflection.getCallerClass()方法获取调用这个方法的Class对象，这是一个native方法:

```
@CallerSensitive
    public static native Class<?> getCallerClass();
```



在OpenJDK的源码中找到此方法的JNI入口(Reflection.c):

```
JNIEXPORT jclass JNICALL Java_sun_reflect_Reflection_getCallerClass__
(JNIEnv *env, jclass unused)
{
    return JVM_GetCallerClass(env, JVM_CALLER_DEPTH);
}
```



其中JVM_GetCallerClass的源码如下，有兴趣的可以研究一下(位于jvm.cpp):

```
JVM_ENTRY(jclass, JVM_GetCallerClass(JNIEnv* env, int depth))
  JVMWrapper("JVM_GetCallerClass");

  // Pre-JDK 8 and early builds of JDK 8 don't have a CallerSensitive annotation; or
  // sun.reflect.Reflection.getCallerClass with a depth parameter is provided
  // temporarily for existing code to use until a replacement API is defined.
  if (SystemDictionary::reflect_CallerSensitive_klass() == NULL || depth != JVM_CALLER_DEPTH) {
    Klass* k = thread->security_get_caller_class(depth);
    return (k == NULL) ? NULL : (jclass) JNIHandles::make_local(env, k->java_mirror());
  }

  // Getting the class of the caller frame.
  //
  // The call stack at this point looks something like this:
  //
  // [0] [ @CallerSensitive public sun.reflect.Reflection.getCallerClass ]
  // [1] [ @CallerSensitive API.method                                   ]
  // [.] [ (skipped intermediate frames)                                 ]
  // [n] [ caller                                                        ]
  vframeStream vfst(thread);
  // Cf. LibraryCallKit::inline_native_Reflection_getCallerClass
  for (int n = 0; !vfst.at_end(); vfst.security_next(), n++) {
    Method* m = vfst.method();
    assert(m != NULL, "sanity");
    switch (n) {
    case 0:
      // This must only be called from Reflection.getCallerClass
      if (m->intrinsic_id() != vmIntrinsics::_getCallerClass) {
        THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), "JVM_GetCallerClass must only be called from Reflection.getCallerClass");
      }
      // fall-through
    case 1:
      // Frame 0 and 1 must be caller sensitive.
      if (!m->caller_sensitive()) {
        THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), err_msg("CallerSensitive annotation expected at frame %d", n));
      }
      break;
    default:
      if (!m->is_ignored_by_security_stack_walk()) {
        // We have reached the desired frame; return the holder class.
        return (jclass) JNIHandles::make_local(env, m->method_holder()->java_mirror());
      }
      break;
    }
  }
  return NULL;
JVM_END
```



获取了这个Class对象caller后用checkAccess方法做一次快速的权限校验，其实现为:

```
volatile Object securityCheckCache;

    void checkAccess(Class<?> caller, Class<?> clazz, Object obj, int modifiers)
        throws IllegalAccessException
    {
        if (caller == clazz) {  // 快速校验
            return;             // 权限通过校验
        }
        Object cache = securityCheckCache;  // read volatile
        Class<?> targetClass = clazz;
        if (obj != null
            && Modifier.isProtected(modifiers)
            && ((targetClass = obj.getClass()) != clazz)) {
            // Must match a 2-list of { caller, targetClass }.
            if (cache instanceof Class[]) {
                Class<?>[] cache2 = (Class<?>[]) cache;
                if (cache2[1] == targetClass &&
                    cache2[0] == caller) {
                    return;     // ACCESS IS OK
                }
                // (Test cache[1] first since range check for [1]
                // subsumes range check for [0].)
            }
        } else if (cache == caller) {
            // Non-protected case (or obj.class == this.clazz).
            return;             // ACCESS IS OK
        }

        // If no return, fall through to the slow path.
        slowCheckMemberAccess(caller, clazz, obj, modifiers, targetClass);
    }
```



首先先执行一次快速校验，一旦调用方法的Class正确则权限检查通过。
若未通过，则创建一个缓存，中间再进行一堆检查（比如检验是否为protected属性）。
如果上面的所有权限检查都未通过，那么将执行更详细的检查，其实现为：

```
// Keep all this slow stuff out of line:
void slowCheckMemberAccess(Class<?> caller, Class<?> clazz, Object obj, int modifiers,
                           Class<?> targetClass)
    throws IllegalAccessException
{
    Reflection.ensureMemberAccess(caller, clazz, obj, modifiers);

    // Success: Update the cache.
    Object cache = ((targetClass == clazz)
                    ? caller
                    : new Class<?>[] { caller, targetClass });

    // Note:  The two cache elements are not volatile,
    // but they are effectively final.  The Java memory model
    // guarantees that the initializing stores for the cache
    // elements will occur before the volatile write.
    securityCheckCache = cache;         // write volatile
}
```



大体意思就是，用Reflection.ensureMemberAccess方法继续检查权限，若检查通过就更新缓存，这样下一次同一个类调用同一个方法时就不用执行权限检查了，这是一种简单的缓存机制。由于JMM的happens-before规则能够保证缓存初始化能够在写缓存之前发生，因此两个cache不需要声明为volatile。
到这里，前期的权限检查工作就结束了。如果没有通过检查则会抛出异常，如果通过了检查则会到下一步。

## 2、调用MethodAccessor的invoke方法

Method.invoke()实际上并不是自己实现的反射调用逻辑，而是委托给sun.reflect.MethodAccessor来处理。
首先要了解Method对象的基本构成，每个Java方法有且只有一个Method对象作为root，它相当于根对象，对用户不可见。当我们创建Method对象时，我们代码中获得的Method对象都相当于它的副本（或引用）。root对象持有一个MethodAccessor对象，所以所有获取到的Method对象都共享这一个MethodAccessor对象，因此必须保证它在内存中的可见性。root对象其声明及注释为：

```
private volatile MethodAccessor methodAccessor;
// For sharing of MethodAccessors. This branching structure is
// currently only two levels deep (i.e., one root Method and
// potentially many Method objects pointing to it.)
//
// If this branching structure would ever contain cycles, deadlocks can
// occur in annotation code.
private Method  root;
```



那么MethodAccessor到底是个啥玩意呢？

```
/** This interface provides the declaration for
    java.lang.reflect.Method.invoke(). Each Method object is
    configured with a (possibly dynamically-generated) class which
    implements this interface.
*/
	public interface MethodAccessor {
    /** Matches specification in {@link java.lang.reflect.Method} */
    public Object invoke(Object obj, Object[] args)
        throws IllegalArgumentException, InvocationTargetException;
}
```

可以看到MethodAccessor是一个接口，定义了invoke方法。分析其Usage可得它的具体实现类有:

- sun.reflect.DelegatingMethodAccessorImpl
- sun.reflect.MethodAccessorImpl
- sun.reflect.NativeMethodAccessorImpl

第一次调用一个Java方法对应的Method对象的invoke()方法之前，实现调用逻辑的MethodAccessor对象还没有创建；等第一次调用时才新创建MethodAccessor并更新给root，然后调用MethodAccessor.invoke()完成反射调用：

```
// NOTE that there is no synchronization used here. It is correct
// (though not efficient) to generate more than one MethodAccessor
// for a given Method. However, avoiding synchronization will
// probably make the implementation more scalable.
private MethodAccessor acquireMethodAccessor() {
    // First check to see if one has been created yet, and take it
    // if so
    MethodAccessor tmp = null;
    if (root != null) tmp = root.getMethodAccessor();
    if (tmp != null) {
        methodAccessor = tmp;
    } else {
        // Otherwise fabricate one and propagate it up to the root
        tmp = reflectionFactory.newMethodAccessor(this);
        setMethodAccessor(tmp);
    }

    return tmp;
}
```



可以看到methodAccessor实例由reflectionFactory对象操控生成，它在AccessibleObject下的声明如下:

```
// Reflection factory used by subclasses for creating field,
// method, and constructor accessors. Note that this is called
// very early in the bootstrapping process.
static final ReflectionFactory reflectionFactory =
    AccessController.doPrivileged(
        new sun.reflect.ReflectionFactory.GetReflectionFactoryAction());
```

再研究一下sun.reflect.ReflectionFactory类的源码：

```
public class ReflectionFactory {

    private static boolean initted = false;
    private static Permission reflectionFactoryAccessPerm
        = new RuntimePermission("reflectionFactoryAccess");
    private static ReflectionFactory soleInstance = new ReflectionFactory();
    // Provides access to package-private mechanisms in java.lang.reflect
    private static volatile LangReflectAccess langReflectAccess;

    // 这里设计得非常巧妙
    // "Inflation" mechanism. Loading bytecodes to implement
    // Method.invoke() and Constructor.newInstance() currently costs
    // 3-4x more than an invocation via native code for the first
    // invocation (though subsequent invocations have been benchmarked
    // to be over 20x faster). Unfortunately this cost increases
    // startup time for certain applications that use reflection
    // intensively (but only once per class) to bootstrap themselves.
    // To avoid this penalty we reuse the existing JVM entry points
    // for the first few invocations of Methods and Constructors and
    // then switch to the bytecode-based implementations.
    //
    // Package-private to be accessible to NativeMethodAccessorImpl
    // and NativeConstructorAccessorImpl
    private static boolean noInflation        = false;
    private static int     inflationThreshold = 15;

    //......

	//这是生成MethodAccessor的方法
    public MethodAccessor newMethodAccessor(Method method) {
        checkInitted();

        if (noInflation && !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) {
            return new MethodAccessorGenerator().
                generateMethod(method.getDeclaringClass(),
                               method.getName(),
                               method.getParameterTypes(),
                               method.getReturnType(),
                               method.getExceptionTypes(),
                               method.getModifiers());
        } else {
            NativeMethodAccessorImpl acc =
                new NativeMethodAccessorImpl(method);
            DelegatingMethodAccessorImpl res =
                new DelegatingMethodAccessorImpl(acc);
            acc.setParent(res);
            return res;
        }
    }

    //......

    /** We have to defer full initialization of this class until after
    the static initializer is run since java.lang.reflect.Method's
    static initializer (more properly, that for
    java.lang.reflect.AccessibleObject) causes this class's to be
    run, before the system properties are set up. */
    private static void checkInitted() {
        if (initted) return;
        AccessController.doPrivileged(
            new PrivilegedAction<Void>() {
                public Void run() {
                    // Tests to ensure the system properties table is fully
                    // initialized. This is needed because reflection code is
                    // called very early in the initialization process (before
                    // command-line arguments have been parsed and therefore
                    // these user-settable properties installed.) We assume that
                    // if System.out is non-null then the System class has been
                    // fully initialized and that the bulk of the startup code
                    // has been run.

                    if (System.out == null) {
                        // java.lang.System not yet fully initialized
                        return null;
                    }

                    String val = System.getProperty("sun.reflect.noInflation");
                    if (val != null && val.equals("true")) {
                        noInflation = true;
                    }

                    val = System.getProperty("sun.reflect.inflationThreshold");
                    if (val != null) {
                        try {
                            inflationThreshold = Integer.parseInt(val);
                        } catch (NumberFormatException e) {
                            throw new RuntimeException("Unable to parse property sun.reflect.inflationThreshold", e);
                        }
                    }

                    initted = true;
                    return null;
                }
            });
    }
}
```



观察前面的声明部分的注释，我们可以发现一些有趣的东西。就像注释里说的，实际的MethodAccessor实现有两个版本，一个是Java版本，一个是native版本，两者各有特点。初次启动时Method.invoke()和Constructor.newInstance()方法采用native方法要比Java方法快3-4倍，而启动后native方法又要消耗额外的性能而慢于Java方法。也就是说，Java实现的版本在初始化时需要较多时间，但长久来说性能较好；native版本正好相反，启动时相对较快，但运行时间长了之后速度就比不过Java版了。这是HotSpot的优化方式带来的性能特性，同时也是许多虚拟机的共同点：跨越native边界会对优化有阻碍作用，它就像个黑箱一样让虚拟机难以分析也将其内联，于是运行时间长了之后反而是托管版本的代码更快些。

为了尽可能地减少性能损耗，HotSpot JDK采用“inflation”的技巧：让Java方法在被反射调用时，开头若干次使用native版，等反射调用次数超过阈值时则生成一个专用的MethodAccessor实现类，生成其中的invoke()方法的字节码，以后对该Java方法的反射调用就会使用Java版本。 这项优化是从JDK 1.4开始的。

研究ReflectionFactory.newMethodAccessor()生产MethodAccessor对象的逻辑，一开始(native版)会生产NativeMethodAccessorImpl和DelegatingMethodAccessorImpl两个对象。
DelegatingMethodAccessorImpl的源码如下：

```
/** Delegates its invocation to another MethodAccessorImpl and can
    change its delegate at run time. */

class DelegatingMethodAccessorImpl extends MethodAccessorImpl {
    private MethodAccessorImpl delegate;

    DelegatingMethodAccessorImpl(MethodAccessorImpl delegate) {
        setDelegate(delegate);
    }

    public Object invoke(Object obj, Object[] args)
        throws IllegalArgumentException, InvocationTargetException
    {
        return delegate.invoke(obj, args);
    }

    void setDelegate(MethodAccessorImpl delegate) {
        this.delegate = delegate;
    }
}
```



它其实是一个中间层，方便在native版与Java版的MethodAccessor之间进行切换。
然后下面就是native版MethodAccessor的Java方面的声明：
sun.reflect.NativeMethodAccessorImpl：

```
/** Used only for the first few invocations of a Method; afterward,
    switches to bytecode-based implementation */

class NativeMethodAccessorImpl extends MethodAccessorImpl {
    private Method method;
    private DelegatingMethodAccessorImpl parent;
    private int numInvocations;

    NativeMethodAccessorImpl(Method method) {
        this.method = method;
    }

    public Object invoke(Object obj, Object[] args)
        throws IllegalArgumentException, InvocationTargetException
    {
        // We can't inflate methods belonging to vm-anonymous classes because
        // that kind of class can't be referred to by name, hence can't be
        // found from the generated bytecode.
        if (++numInvocations > ReflectionFactory.inflationThreshold()
                && !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) {
            MethodAccessorImpl acc = (MethodAccessorImpl)
                new MethodAccessorGenerator().
                    generateMethod(method.getDeclaringClass(),
                                   method.getName(),
                                   method.getParameterTypes(),
                                   method.getReturnType(),
                                   method.getExceptionTypes(),
                                   method.getModifiers());
            parent.setDelegate(acc);
        }

        return invoke0(method, obj, args);
    }

    void setParent(DelegatingMethodAccessorImpl parent) {
        this.parent = parent;
    }

    private static native Object invoke0(Method m, Object obj, Object[] args);
}
```



每次NativeMethodAccessorImpl.invoke()方法被调用时，程序调用计数器都会增加1，看看是否超过阈值；一旦超过，则调用MethodAccessorGenerator.generateMethod()来生成Java版的MethodAccessor的实现类，并且改变DelegatingMethodAccessorImpl所引用的MethodAccessor为Java版。后续经由DelegatingMethodAccessorImpl.invoke()调用到的就是Java版的实现了。
到这里，我们已经追寻到native版的invoke方法在Java一侧声明的最底层 - invoke0了，下面我们将深入到HotSpot JVM中去研究其具体实现。

# 寻根溯源 - 在JVM层面探究invoke0方法

invoke0方法是一个native方法,它在HotSpot JVM里调用JVM_InvokeMethod函数:

```
JNIEXPORT jobject JNICALL Java_sun_reflect_NativeMethodAccessorImpl_invoke0
(JNIEnv *env, jclass unused, jobject m, jobject obj, jobjectArray args)
{
    return JVM_InvokeMethod(env, m, obj, args);
}
```



openjdk/hotspot/src/share/vm/prims/jvm.cpp

```
JVM_ENTRY(jobject, JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0))
  JVMWrapper("JVM_InvokeMethod");
  Handle method_handle;
  if (thread->stack_available((address) &method_handle) >= JVMInvokeMethodSlack) {
    method_handle = Handle(THREAD, JNIHandles::resolve(method));
    Handle receiver(THREAD, JNIHandles::resolve(obj));
    objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));
    oop result = Reflection::invoke_method(method_handle(), receiver, args, CHECK_NULL);
    jobject res = JNIHandles::make_local(env, result);
    if (JvmtiExport::should_post_vm_object_alloc()) {
      oop ret_type = java_lang_reflect_Method::return_type(method_handle());
      assert(ret_type != NULL, "sanity check: ret_type oop must not be NULL!");
      if (java_lang_Class::is_primitive(ret_type)) {
        // Only for primitive type vm allocates memory for java object.
        // See box() method.
        JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
      }
    }
    return res;
  } else {
    THROW_0(vmSymbols::java_lang_StackOverflowError());
  }
JVM_END
```



其关键部分为Reflection::invoke_method:
openjdk/hotspot/src/share/vm/runtime/reflection.cpp

```
oop Reflection::invoke_method(oop method_mirror, Handle receiver, objArrayHandle args, TRAPS) {
  oop mirror             = java_lang_reflect_Method::clazz(method_mirror);
  int slot               = java_lang_reflect_Method::slot(method_mirror);
  bool override          = java_lang_reflect_Method::override(method_mirror) != 0;
  objArrayHandle ptypes(THREAD, objArrayOop(java_lang_reflect_Method::parameter_types(method_mirror)));

  oop return_type_mirror = java_lang_reflect_Method::return_type(method_mirror);
  BasicType rtype;
  if (java_lang_Class::is_primitive(return_type_mirror)) {
    rtype = basic_type_mirror_to_basic_type(return_type_mirror, CHECK_NULL);
  } else {
    rtype = T_OBJECT;
  }

  instanceKlassHandle klass(THREAD, java_lang_Class::as_Klass(mirror));
  Method* m = klass->method_with_idnum(slot);
  if (m == NULL) {
    THROW_MSG_0(vmSymbols::java_lang_InternalError(), "invoke");
  }
  methodHandle method(THREAD, m);

  return invoke(klass, method, receiver, override, ptypes, rtype, args, true, THREAD);
}
```



这里面又会涉及到Java的对象模型(klass和oop)，以后继续补充。(**留坑**)

# 寻根溯源 - Java版的实现

Java版MethodAccessor的生成使用MethodAccessorGenerator实现，由于代码太长，这里就不贴代码了，只贴一下开头的注释：

```
/** Generator for sun.reflect.MethodAccessor and
    sun.reflect.ConstructorAccessor objects using bytecodes to
    implement reflection. A java.lang.reflect.Method or
    java.lang.reflect.Constructor object can delegate its invoke or
    newInstance method to an accessor using native code or to one
    generated by this class. (Methods and Constructors were merged
    together in this class to ensure maximum code sharing.) */
```



这里运用了asm动态生成字节码技术（sun.reflect.ClassFileAssembler)，原理比较复杂，后面讲到AOP要用到asm技术的时候再深入了解一下吧。

# 本篇总结

简单地画了个图表示invoke方法的过程，日后再更时序图：

[![invoke方法的过程](http://img.blog.csdn.net/20150626130739796)](http://img.blog.csdn.net/20150626130739796)

# 番外篇

1. MagicAccessorImpl是什么鬼？

原本Java的安全机制使得不同类之间不是任意信息都可见，但JDK里面专门设了个MagicAccessorImpl标记类开了个后门来允许不同类之间信息可以互相访问（由JVM管理）：

```
/** <P> MagicAccessorImpl (named for parity with FieldAccessorImpl and
    others, not because it actually implements an interface) is a
    marker class in the hierarchy. All subclasses of this class are
    "magically" granted access by the VM to otherwise inaccessible
    fields and methods of other classes. It is used to hold the code
    for dynamically-generated FieldAccessorImpl and MethodAccessorImpl
    subclasses. (Use of the word "unsafe" was avoided in this class's
    name to avoid confusion with {@link sun.misc.Unsafe}.) </P>

    <P> The bug fix for 4486457 also necessitated disabling
    verification for this class and all subclasses, as opposed to just
    SerializationConstructorAccessorImpl and subclasses, to avoid
    having to indicate to the VM which of these dynamically-generated
    stub classes were known to be able to pass the verifier. </P>

    <P> Do not change the name of this class without also changing the
    VM's code. </P> */

class MagicAccessorImpl {
}
```

1. @CallerSensitive注解又是什么鬼？

详见：[JEP 176: Mechanical Checking of Caller-Sensitive Methods](http://openjdk.java.net/jeps/176)

> Summary: Improve the security of the JDK’s method-handle implementation by replacing the existing hand-maintained list of caller-sensitive methods with a mechanism that accurately identifies such methods and allows their callers to be discovered reliably.

JDK 1.8才引进了这个注解，因此在老版本的反射实现里并没有这个玩意。这是它的定义：

```
/**
 * A method annotated @CallerSensitive is sensitive to its calling class,
 * via {@link sun.reflect.Reflection#getCallerClass Reflection.getCallerClass},
 * or via some equivalent.
 *
 * @author John R. Rose
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({METHOD})
public @interface CallerSensitive {
}
```



简而言之，用`@CallerSensitive`注解修饰的方法从一开始就知道具体调用它的对象，这样就不用再经过一系列的检查才能确定具体调用它的对象了。它实际上是调用`sun.reflect.Reflection.getCallerClass`方法。

Reflection类位于调用栈中的0帧位置，`sun.reflect.Reflection.getCallerClass()`方法返回调用栈中从0帧开始的第x帧中的类实例。该方法提供的机制可用于确定调用者类，从而实现“感知调用者（Caller Sensitive）”的行为，即允许应用程序根据调用类或调用栈中的其它类来改变其自身的行为。