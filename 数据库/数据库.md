# Mysql

## 数据库基本概念

```
（1）数据

所谓数据（Data）是指对客观事物进行描述并可以鉴别的符号，这些符号是可识别的、抽象的。它不仅仅指狭义上的数字，而是有多种表现形式：字母、文字、文本、图形、音频、视频等。现在计算机存储和处理的数据范围十分广泛，而描述这些数据的符号也变得越来越复杂了。

（2）数据库

数据库（Database，DB）指的是以一定格式存放、能够实现多个用户共享、与应用程序彼此独立的数据集合。

（3）数据库管理系统

数据库管理系统（Database Management System，DBMS）是用来定义和管理数据的软件。如何科学的组织和存储数据，如何高效的获取和维护数据，如何保证数据的安全性和完整性，这些都需要靠数据库管理系统完成。目前，比较流行的数据库管理系统有：Oracle、MySQL、SQL Server、DB2等。

（4）数据库应用程序

数据库应用程序（Database Application System，DBAS）是在数据库管理系统基础上，使用数据库管理系统的语法，开发的直接面对最终用户的应用程序，如学生管理系统、人事管理系统、图书管理系统等。

（5）数据库管理员

数据库管理员（Database Administrator，DBA）是指对数据库管理系统进行操作的人员，其主要负责数据库的运营和维护。

（6）最终用户

最终用户（User）指的是数据库应用程序的使用者。用户面向的是数据库应用程序（通过应用程序操作数据），并不会直接与数据库打交道。

（7） 数据库系统

数据库系统（Database System，DBS）一般是由数据库、数据库管理系统、数据库应用程序、数据库管理员和最终用户构成。其中DBMS是数据库系统的基础和核心。
```

![image-20221029105828890](/Users/rain/Library/Application Support/typora-user-images/image-20221029105828890.png)



## 数据库类型和常见的关系型类型

```
数据库的类型主要分为四大类：一：关系型数据库。二：非关系型数据库。三：网状数据库。四：层次数据库。目前最常见的数据库模型主要是：关系型数据库和非关系型数据库。

关系型数据库和非关系型数据库。

1. 关系型数据库

关系型数据库模型是将复杂的数据结构用较为简单的二元关系（二维表）来表示，如图1-4所示。在该类型数据库中，对数据的操作基本上都建立在一个或多个表格上，我们可以采用结构化查询语言（SQL）对数据库进行操作。关系型数据库是目前主流的数据库技术，其中具有代表性的数据库管理系统有：Oracle、DB2、SQL Server、MySQL等。

如下图：

 ps:关系  =   二维表。

2. 非关系型数据库NOSQL

NOSQL（Not Only SQL）泛指非关系型数据库。关系型数据库在超大规模和高并发的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题。NOSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。常见的非关系型数据库管理系统有Memcached、MongoDB，redis，HBase等。 

注：关系型数据库都是把数据保存在硬盘上，不会随着关机而丢失数据

非关系型数据库是吧数据保存在内存中，电脑一旦关机数据也会丢失。

【2】常见的关系型数据库

虽然非关系型数据库的优点很多，但是由于其并不提供SQL支持、学习和使用成本较高并且无事务处理，所以本书的重点是关系型数据库。下面我们将介绍一下常用的关系型数据库管理系统。

1. Oracle

Oracle数据库是由美国的甲骨文（Oracle）公司开发的世界上第一款支持SQL语言的关系型数据库。经过多年的完善与发展，Oracle数据库已经成为世界上最流行的数据库，也是甲骨文公司的核心产品。

Oracle数据库具有很好的开放性，能在所有的主流平台上运行，并且性能高、安全性高、风险低；但是其对硬件的要求很高、管理维护和操作比较复杂而且价格昂贵，所以一般用在满足对银行、金融、保险等行业大型数据库的需求上。

2. DB2

DB2是IBM公司著名的关系型数据库产品。DB2无论稳定性，安全性，恢复性等等都无可挑剔，而且从小规模到大规模的应用都可以使用，但是用起来非常繁琐，比较适合大型的分布式应用系统。

3. SQL Server

SQL Server是由Microsoft开发和推广的关系型数据库，SQL Server的功能比较全面、效率高，可以作为中型企业或单位的数据库平台。SQL Server可以与Windows操作系统紧密继承，无论是应用程序开发速度还是系统事务处理运行速度，都能得到大幅度提升。但是，SQL Server只能在Windows系统下运行，毫无开放性可言。

4. MySQL

MySQL是一种开放源代码的轻量级关系型数据库，MySQL数据库使用最常用的结构化查询语言（SQL）对数据库进行管理。由于MySQL是开放源代码的，因此任何人都可以在General Public License的许可下下载并根据个人需要对其缺陷进行修改。

由于MySQL数据库体积小、速度快、成本低、开放源码等优点，现已被广泛应用于互联网上的中小型网站中，并且大型网站也开始使用MySQL数据库，如网易、新浪等。  

```

![image-20221029110829827](/Users/rain/Library/Application Support/typora-user-images/image-20221029110829827.png)

​								             关系型数据库

## MySQL介绍

```
MySQL数据库最初是由瑞典MySQL AB公司开发，2008年1月16号被Sun公司收购。2009年，SUN又被Oracle收购。MySQL是目前IT行业最流行的开放源代码的数据库管理系统，同时它也是一个支持多线程高并发多用户的关系型数据库管理系统。MySQL之所以受到业界人士的青睐，主要是因为其具有以下几方面优点：

ps:1. 开放源代码

MySQL最强大的优势之一在于它是一个开放源代码的数据库管理系统。开源的特点是给予了用户根据自己需要修改DBMS的自由。MySQL采用了General Public License，这意味着授予用户阅读、修改和优化源代码的权利，这样即使是免费版的MySQL的功能也足够强大，这也是为什么MySQL越来越受欢迎的主要原因。

ps:2. 跨平台

MySQL可以在不同的操作系统下运行，简单地说，MySQL可以支持Windows系统、UNIX系统、Linux系统等多种操作系统平台。这意味着在一个操作系统中实现的应用程序可以很方便地移植到其他的操作系统下。

ps:3. 轻量级

MySQL的核心程序完全采用多线程编程，这些线程都是轻量级的进程，它在灵活地为用户提供服务的同时，又不会占用过多的系统资源。因此MySQL能够更快速、高效的处理数据。

ps:4. 成本低

MySQL分为社区版和企业版，社区版是完全免费的，而企业版是收费的。即使在开发中需要用到一些付费的附加功能，价格相对于昂贵的Oracle、DB2等也是有很大优势的。其实免费的社区版也支持多种数据类型和正规的SQL查询语言，能够对数据进行各种查询、增加、删除、修改等操作，所以一般情况下社区版就可以满足开发需求了，而对数据库可靠性要求比较高的企业可以选择企业版。

另外，PHP中提供了一整套的MySQL函数，对MySQL进行了全方位的强力支持。 

总体来说，MySQL是一款开源的、免费的、轻量级的关系型数据库，其具有体积小、速度快、成本低、开放源码等优点，其发展前景是无可限量的。 

PS：社区版与企业版主要的区别是：

1. 社区版包含所有MySQL的最新功能，而企业版只包含稳定之后的功能。换句话说，社区版可以理解为是企业版的测试版。 

2.MySQL官方的支持服务只是针对企业版，如果用户在使用社区版时出现了问题，MySQL官方是不负责任的。  
```



**Mysql 配置：**

```
密码：

Li123456@



修改端口号：

配置文件为不可写，需要加超级权限

修改配置文件：

 sudo vim /Library/LaunchDaemons/com.oracle.oss.mysql.mysqld.plist

将：<string>--port=3307</string>

改为：<string>--port=3306</string>



文件权限

-rwxr-xr-x  1 root  wheel  1808  7  7 09:08 com.oracle.oss.mysql.mysqld.plist
```

## Mysql登录、退出、操作

### 1.登录

执行mysql.exe命令错误的时候，错误，需要配置环境变量

MAC：

```shell
说明还没设置环境变量，即在终端通过vim编辑 .zshrc 配置文件

hxy@xiaoxiaobaobeideiMac ~ % sudo vim ~/.zshrc 
打开后，按下 i 键，进入编辑模式，在配置文件中添加如下：
#MySQL
export PATH=$PATH:/usr/local/mysql/bin
然后在按 esc 键退出编辑模式，在输入 :wq !退出并保存

然后在执行 source ~/.zshrc 使环境变量配置生效
hxy@xiaoxiaobaobeideiMac ~ % source ~/.zshrc

然后在终端执行 mysql --version 查看版本
hxy@xiaoxiaobaobeideiMac ~ % mysql --version
mysql  Ver 8.0.23 for macos10.15 on x86_64 (MySQL Community Server - GPL)
```



```shell
登录的命令：mysql -hlocalhost -uroot –p
mysql：bin目录下的文件mysql.exe。

mysql是MySQL的命令行工具，是一个客户端软件，可以对任何主机的mysql服务（即后台运行的mysqld）发起连接。

-h：host主机名。后面跟要访问的数据库服务器的地址；如果是登录本机，可以省略

-u：user 用户名。后面跟登录数据的用户名，第一次安装后以root用户来登录，是MySQL的管理员用户

-p: password 密码。一般不直接输入，而是回车后以保密方式输入。
```



### 2.访问数据库

显示`MySQL`中的数据库列表：`show databases;` 默认有四个自带的数据库，每个数据库中可以有多个数据库表、视图等对象。

```
显示MySQL中的数据库列表：show databases; 默认有四个自带的数据库，每个数据库中可以有多个数据库表、视图等对象。
mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
4 rows in set (0.01 sec)

切换当前数据库的命令：use mysql;


MySQL下可以有多个数据库，如果要访问哪个数据库，需要将其置为当前数据库。
该命令的作用就是将数据库mysql（默认提供的四个数据库之一的名字）置为当前数据库。
显示当前数据库的所有数据库表：show tables;
MySQL 层次：不同项目对应不同的数据库组成 - 每个数据库中有很多表 - 每个表中有很多数据
```

### 3.退出数据库

退出数据库可以使用`quit;`或者`exit`命令完成，也可以用`\q;` 完成退出操作。



## 使用使用图形化客户端Navicat2连接mysql、

#### 1.Navicat简介

Navicat 是一款成熟可靠的数据库管理工具，深受技术人员的喜爱。它是以直觉化的图形用户界面而建的，让你可以以安全并且简单的方式创建、组织、访问并共用信息。

Navicat 可以用来对本机或远程的 MySQL、SQL Server、SQLite、Oracle 及 PostgreSQL 数据库进行管理及开发。可运行在 Windows 、macOS、Linux 三种操作系统中，可提供数据传输、数据同步、结构同步、导入、导出、备份、还原、报表创建工具及计划以协助管理数据等功能。

Navicat 目前在市场上有很多在用的版本，大体可分为可连接多种数据源的 Navicat Premium 和用于单数据源的 Navicat for MySQL 等。不过不同版本之间差别并不大。





## SQL语言入门

###  【1】什么是 SQL

SQL语言有40多年的历史，从它被应用至今几乎无处不在。我们消费的每一笔支付记录，收集的每一条用户信息，发出去的每一条消息，都会使用数据库或与其相关的产品来存储，而操纵数据库的语言正是 SQL ！

SQL 对于现在的互联网公司生产研发等岗位几乎是一个必备技能，如果不会 SQL 的话，可能什么都做不了。你可以把 SQL 当做是一种工具，利用它可以帮助你完成你的工作，创造价值
SQL 是用于访问和处理数据库的标准的计算机语言。

SQL 指结构化查询语言
SQL 使我们有能力访问数据库
SQL 是一种 ANSI 的标准计算机语言

SQL 可与数据库程序协同工作，比如 MS Access、DB2、Informix、MS SQL Server、Oracle、Sybase 以及其他数据库系统。但是由于各种各样的数据库出现，导致很多不同版本的 SQL 语言，为了与 ANSI 标准相兼容，它们必须以相似的方式共同地来支持一些主要的关键词（比如 SELECT、UPDATE、DELETE、INSERT、WHERE 等等），这些就是我们要学习的SQL基础。

### 【2】SQL语言分为五个部分：

- 数据查询语言（data query language，DQL）：DQL主要用于数据的查询，其数据基本结构是使用select字句，form字句和where字句的组合来查询一条或多条数据。

- 数据操作语言（data manipulation language，DML）DML 主要用于对数据库中的数据进行增加，修改和删除的操作，主要包括：

  1.Insert ：添加数据
  2.Update：修改数据
  3.Delete：删除数据

- 数据定义语言（data definition language，DDL）DDL主要针对数据库对象（数据库，表，索引，视图，触发器，存储过程，函数）进行创建，修改和删除操作。主要包括：

  1.Create：创建数据库对象
  2.Alter：修改数据库对象
  3.Drop：删除数据库对象

- 数据控制语言（data control language，DCL）DCL用来授予或回收访问数据库的权限，主要包括：

  1.Grant：授予用户某种权限
  2.Revoke：收回授予的某种权限

- 事物控制语言（transaction controllanguage，TCL）TCL用于数据库的事务管理。主要包括：

  1.Start  transaction ：开启事务
  2.Commit：提交事务
  3.Rollback ：回滚事务

## DDL_DML_创建数据库表

【1】认识数据表

表【Table】是数据库中数据存储最常见和最简单的一种形式，数据库可以将复杂的数据结构用较为简单的二维表来表示。二维表是有由行和列组成的，分别都包含着数据库，如表所示。

| 学号     | 姓名 | 性别 | 年龄 |
| -------- | ---- | ---- | ---- |
| 17071401 | 张三 | 男   | 20   |
| 17071402 | 李四 | 女   | 19   |
| 17071403 | 王五 | 男   | 23   |
| 17071404 | 赵六 | 女   | 17   |

每个表都是由若干个行和列组成的，在数据库中表中的行被称为记录，表中的列被称为是这些记录的字段。

记录也被称为一行数据，是表里的一行，在关系型数据库中，一行数据是指一条完整的记录。

字段是表里的一列，用于保存每条记录的特定信息，如上表所示的学生信息表中的字段包括“学号”、姓名、性别和年龄。数据表的一列包含了某个特定字段的全部信息。

【2】创建数据库表 t_student

- 建立一张用来存储学生信息的表
- 字段包含姓名、姓名、性别和年龄。入学日期，email等
- 学号是主键 = 不能为空 + 唯一
- 姓名不能为空
- 性别默认值是男
- Email唯一

(1)创建数据库

字符集：utf8mb4

（2）创建查询

![image-20221029150443057](/Users/rain/Library/Application Support/typora-user-images/image-20221029150443057.png)

(3)创建数据库表：

```sql

##这是一个单行注释
/*
多行注释
多行注释
*/

/*
- 建立一张用来存储学生信息的表
- 字段包含姓名、姓名、性别和年龄。入学日期，email等
*/

-- 创建数据库表：
create table t_student(
 sno int(6),  -- 6显示长度
 sname varchar(10),  -- 10个字符
 sex char(1),
 age int(3),
 enterdate date,
 classname varchar(10),
 email varchar(15)
 
);

-- 查看表的结构：展示表的字段的的详细信息
desc t_student;

-- 查看表中数据：
select * from t_student;

-- 查看建表语句：
show create table t_student;

/*
CREATE TABLE `t_student` (
  `sno` int DEFAULT NULL,
  `sname` varchar(10) DEFAULT NULL,
  `sex` char(1) DEFAULT NULL,
  `age` int DEFAULT NULL,
  `enterdate` date DEFAULT NULL,
  `classname` varchar(10) DEFAULT NULL,
  `email` varchar(15) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
*/
```



## 数据库表列类型

- 整数类型

![截屏2022-10-29 15.22.59](/Users/rain/Desktop/截屏2022-10-29 15.22.59.png)

MySQL支持选择在该类型关键字后面的括号内指定整数值的显示宽度(例如，INT(4))。显示宽度并不限制可以在列内保存的值的范围，也不限制超过列的指定宽度的值的显示

主键自增：不使用序列，通过auto_increment，要求是整数类型

- 浮点数类型

  ![image-20221029152601146](/Users/rain/Library/Application Support/typora-user-images/image-20221029152601146.png)

需要注意的是与整数类型不一样的是，浮点数类型的宽度不会自动扩充。 score double(4,1)
score double(4,1)--小数部分为1位，总宽度4位，并且不会自动扩充。

- 字符串类型

  ![image-20221029152631640](/Users/rain/Library/Application Support/typora-user-images/image-20221029152631640.png)

CHAR和VARCHAR类型相似，均用于存于较短的字符串，主要的不同之处在于存储方式。CHAR类型长度固定，VARCHAR类型的长度可变。

- 日期和时间类型

  ![image-20221029152725065](/Users/rain/Library/Application Support/typora-user-images/image-20221029152725065.png)

- TIMESTEMP类型的数据指定方式与DATETIME基本相同，两者的不同之处在于以下几点：
- 数据的取值范围不同，TIMESTEMP类型的取值范围更小。
- 如果我们对TIMESTAMP类型的字段没有明确赋值，或是被赋与了NULL值，MySQL会自动将该字段赋值为系统当前的日 期与时间。
- TIMESTEMP类型还可以使用CURRENT_TIMESTAMP来获取系统当前时间。
- TIMESTEMP类型有一个很大的特点，那就是时间是根据时区来显示的。例如，在东八区插入的TIMESTEMP数据为2017-07-11 16:43:25，在东七区显示时，时间部分就变成了15:43:25，在东九区显示时，时间部分就变成了17:43:25。

## DML_添加数据

注意事项：

1.int 宽度是显示宽度，如果超过，可以自动增大宽度，int底层都是4个字节

2.时间的方式多样 ‘1234-4-3’ “1234/11/11” “2222.2.2”

3.字符串不区分单引号和双引号

4.如何写入当前的时间 now(), sys date(), CURRENT_DATE()

5.char archer 是字符的个数，不是字节的个数，可以使用binary, varbinary表示定长和不定长的字节个数

6.如果不是全字段插入数据的话，需要加入字段的名字。



```sql
-- 查看表记录：
select * from t_student;


-- 在 t_student数据库表中插入数据：
insert into t_student values(1,'张三','男',18,'2022-5-8','软件1班','123@126.com');
insert into t_student values(13333812,'张三','男',18,'2022-5-8','软件1班','123@126.com');
insert into t_student values(2,'张三力达呵','男',18,'2022/5/8','软件1班','123@126.com');
insert into t_student values(2,'李四','男',18,'202.5.8','软件1班','123@126.com');
insert into t_student values(2,'李四','男',22,'202.5.8','软件1班','123@126.com');
insert into t_student values(2,'时间','男',22, SYSDATE(),'软件1班','123@126.com');
insert into t_student (sno,sname,enterdate) values (22,'软件1班','2033-3-3');
```



## DML_修改数据、删除数据

注意事项：

1.关键字，表名，字段名不区分大小写

2.默认情况下，内容不区分大小写

3.删除操作from关键字不可缺少

4.修改，删除数据别忘记加限制条件

```sql
-- 修改表格数据
UPDATE t_student set sex = '女';
UPDATE t_student set sex = '男' where sno = 2;
UPDATE t_student SET sex = '女' WHERE age = 2;
update t_student set CLASSNAME = 'java01' where sno = 10;
update t_student set age = 18 where CLASSNAME = 'java01';


-- 删除表格数据
DELETE from t_student where sno = 2;
```

## DDL_修改数据、删除数据库表

```sql
-- 查看数据：
select * from t_student;

-- 修改表的结构：
-- 增加一列：（放在最前面）
alter table t_student add score double(5,2) FIRST;  -- 5:总位数 2:小数位

-- 增加一列：（放在sex列的后面）
alter table t_student add score double(5,2) AFTER sex;  -- 5:总位数 2:小数位


-- 删除一列: 
ALTER table t_student drop score;


-- 修改一列：
alter TABLE t_student MODIFY score FLOAT(4,1); -- MODIFY 修改类的类型定义，但是不会改变列的名字
ALTER TABLE t_student CHANGE score score1 DOUBLE(6,3); -- changge TINYINT


-- 删除表：
drop table t_student;


```



## 表的完整性约束

### 非外键约束

为防止不规范的数据存入数据库，在用户对数据进行插入、修改、删除等操作时，Mysql提供了一种机制来检查数据库中的数据是否满足规定的条件，以保证数据库中数据的准确性和一致性，这种机制就是完整性约束。

Mysql中主要支持以下几种完整性约束，如表所示，其中check约束是Mysql8中提供的支持。

| 约束条件       | 约束描述                                       |
| -------------- | ---------------------------------------------- |
| PRIMARY KEY    | 主键约束，约束字段的值可唯一地址标识对应的记录 |
| NOT NULL       | 非空约束，约束字段的值不能为空                 |
| UNIQUE         | 唯一约束，约束字段的值是唯一的                 |
| CHECK          | 检查约束，限制某个字段的默认值                 |
| DEFAUT         | 默认值约束，约束字段的默认值                   |
| AUTO_INCREMENT | 自动增加约束，约束字段的值自动递增             |
| FOREIGN KEY    | 外键约束，约束表与表之间的关系                 |



```sql
/*

- 建立一张用来存储学生信息的表
- 字段包含姓名、姓名、性别和年龄。入学日期，email等

约束：
建立一张用来存储学生信息的表：
字段包含学会、姓名、年龄、入学日期、班级、email等信息
【1】学号是主键 = 不能为空 + 唯一，主键的作用：可以通过主键查到唯一的一条记录 
【2】如果主键是整数类型，那么需要自增
【3】姓名不能为空
【4】Email唯一
【5】性别默认值是男
【6】性别只能是男女
【7】年龄只能在18-50之间
*/

-- 创建数据库表：
create table t_student(
 sno int(6) PRIMARY key auto_increment,  -- 6显示长度
 sname varchar(10) not NULL,  -- 10个字符
 sex char(1) DEFAULT '男' check (sex='男' || sex='女'),
 age int(3) CHECK (age>=18 and age<=50),
 enterdate date,
 classname varchar(10),
 email varchar(15) UNIQUE
 
);


-- 添加数据

INSERT into t_student values (101011,"李四",null,29,"2022.2.2","java_01","133@163.com");
-- > 1048 - Column 'sname' cannot be null 不能为空
-- INSERT into t_student values (101111,NULL,null,29,"2022.2.2","java_01","099@163.com");
-- //如果主键没有设定值，或者用null,default 都可以完成主键自增的效果
insert into t_student (sname,enterdate) values ('菲菲',"2029-4-6");
insert into t_student VALUES (null,'小明','男',21,'2023-1-1','java班','xm@163.com');
insert into t_student VALUES (DEFAULT,'小红',"女",18,'2022-2-2','jaba','xm@99.com');
-- --如果sql报错，可能主键就浪费了，后续插入的主键是不连号的，我们主键也不要求是连号的。

-- 查看数据：
SELECT * from t_student;
```

【2】约束从作用上可以分为两类：

(1) 表级约束： 可以约束表中任意一个多个字段，与列定义相互独立，不包含在列定义中；与定义用’，’分割；必须指出要约束的列的名称；

（2）列级约束：包含在列定义中，直接跟在该列的其他定义之后，用空格分割；不必指定列名

```sql
-- 删除表
drop table t_student;

-- 创建数据库表：
CREATE TABLE t_student(
	sno int(6) auto_increment,
	sname VARCHAR(5) not null,
	sex char(1) DEFAULT '男',
	age int(3),
	enterdate date,
	classname varchar(10),
	email VARCHAR(17),
	CONSTRAINT pk_stu PRIMARY key (sno),  -- pk_stu主键约束的名字
	CONSTRAINT ck_stu_sex check (sex = '男' || sex = '女'),
	CONSTRAINT ck_stu_age check (age >= 18 and age <= 50),
	CONSTRAINT uq_stu_email UNIQUE (email)

);

-- 添加数据：
insert into t_student VALUES (1, '站三','男',21,'2022-1-1','java包','23@8.com');
-- > 1062 - Duplicate entry '23@8.com' for key 't_student.uq_stu_email'
-- > 3819 - Check constraint 'ck_stu_age' is violated.

insert into t_student VALUES (3, '站三',null,19,'2022-1-1','java包','29@8.com');



-- 查看表信息
select * FROM t_student;

```

【3】在创建表之后添加约束

```sql
-- 删除
drop table t_student;


-- 创建数据库表：
create table t_student(
 sno int(6),  -- 6显示长度
 sname varchar(10) not null,  -- 10个字符
 sex char(1) DEFAULT('男'),
 age int(3),
 enterdate date,
 classname varchar(10),
 email varchar(15)
 
);

-- 在创建表以后添加约束：
alter table t_student add CONSTRAINT pk_stu PRIMARY key (sno);  -- 主键约束
alter table t_student modify sno int(6) auto_increment;
alter table t_student add CONSTRAINT ck_stu_sex check (sex = '男' || sex = '女');
alter table t_student add CONSTRAINT ck_stu_age check (age >= 18 and age <= 50);
alter table t_student add CONSTRAINT uq_stu_email UNIQUE (email);


-- 查看表结构
desc t_student;
```



### 外键约束

【1】什么是外键约束？

- 外键约束(FOREIGN KEY，缩写FK)是用来实现数据库表的参照完整性的。外键约束可以使两张表紧密的结合起来，特别是针对修改或者删除的级联操作时，会保证数据的完整性。
- 外键是指表中某个字段的值依赖于另一张表中某个字段的值，而被依赖的字段必须具有主键约束或者唯一约束。被依赖的表我们通常称之为父表或者主表，设置外键约束的表称为子表或者从表。

![image-20221031163602506](/Users/rain/Library/Application Support/typora-user-images/image-20221031163602506.png)



【2】sql展示：

```sql
-- 创建父表：班级表：
create table t_class(
 cno int(6) PRIMARY KEY auto_increment,
 sname VARCHAR(10) not null,
 room char(4)
 
);


-- 可以一次性添加多条记录
-- 添加数据：
INSERT into t_class VALUES (null, 'java01', 'roo1'),(null, 'java02', 'ro43'), (null,'java01','r191');


-- 查看班级表信息：
SELECT * from t_class;
-- 学生表删除；
drop table t_student;
-- 创建字表-学生表
CREATE table t_student(
	sno int(6) PRIMARY KEY auto_increment,
	sname varchar(5) not null,
	classno int(4) -- 取值参考t_class中的sno字段，不要去字段名字完全重复，但是类型长度定义 尽量要求相同
);


-- 添加学生信息：
insert into t_student VALUES (null,'张三',1),(null,'小雨',2),(null,'王武',1);


-- 查看学生表:
SELECT * FROM t_student;

-- 删除学生表
drop TABLE t_student;


-- 出现问题：
-- 1.添加一个学生对应的班级编码为4:
insert into t_student values (null, '露露',4);
-- 2.删除班级2:
delete from t_class WHERE cno = 2;


-- 出现的问题： 你现在的外键约束，没有用语法编译，只是逻辑上认为班级编号是外键，没有从语法上定义
-- 解决办法： 添加外键约束
-- 注意：外键约束只有表级约束，没有列级约束：
CREATE table t_student(
		sno int(6) PRIMARY KEY auto_increment,
		sname varchar(5) not null,
		classno int(4) -- 取值参考t_class中的sno字段，不要去字段名字完全重复，但是类型长度定义 尽量要求相同
		constraint fk_stu_classno foreign key (classno) references t_class (cno)
);

CREATE table t_student(
		sno int(6) PRIMARY KEY auto_increment,
		sname varchar(5) not null,
		classno int(4) -- 取值参考t_class中的sno字段，不要去字段名字完全重复，但是类型长度定义 尽量要求相同
);

alter table t_student add constraint fk_stu_classno foreign key (classno) references t_class (cno);


-- 添加学生信息：
-- > 1452 - Cannot add or update a child row: a foreign key constraint fails (`mytestdb`.`t_student`, CONSTRAINT `fk_stu_classno` FOREIGN KEY (`classno`) REFERENCES `t_class` (`cno`))
insert into t_student VALUES (null,'张三',1),(null,'小雨',3),(null,'王武',1);

-- 删除班级1:
-- 2.删除班级2:
-- > 1451 - Cannot delete or update a parent row: a foreign key constraint fails (`mytestdb`.`t_student`, CONSTRAINT `fk_stu_classno` FOREIGN KEY (`classno`) REFERENCES `t_class` (`cno`))
delete FROM t_class where cno =1;
```



```sql

-- 学生表删除；
drop table t_student;
-- 删除班级表
drop table t_class;
-- 创建字表-学生表
CREATE table t_student(
	sno int(6) PRIMARY KEY auto_increment,
	sname varchar(5) not null,
	classno int(4) -- 取值参考t_class中的sno字段，不要去字段名字完全重复，但是类型长度定义 尽量要求相同
);

alter table t_student add CONSTRAINT cs_stu_cno FOREIGN key (classno) REFERENCES t_class (cno);


-- 创建父表：班级表：
create table t_class(
 cno int(6) PRIMARY KEY auto_increment,
 sname VARCHAR(10) not null,
 room char(4)
 
);


-- 可以一次性添加多条记录
-- 添加数据：
INSERT into t_class VALUES (null, 'java01', 'roo1'),(null, 'java02', 'ro43'), (null,'java01','r191'),(4,'家吧01','r404');

-- 添加学生信息：
insert into t_student VALUES (null,'张三',1),(null,'小雨',2),(null,'王武',3),(null,'赵四',4);

-- 查看学生信息:
SELECT * FROM t_student;
-- 查看班级信息:
SELECT * FROM t_class;



-- 删除班级2: 如果直接删除的话肯定不行因为有外键约束
-- 加入外键策略：
-- 策略1: no action 不允许操作
-- 通过操作sql来完成
-- 先把班级2的学生对应的班级 改为null
update t_student set classno = null where classno =2;
-- 然后再删除班机2
delete from t_class where cno = 2;


-- 测略2: cascade 级联操作：操作主表的时候影响从表的外键信息：
-- 先删除之前的外键约束：
alter TABLE t_student drop FOREIGN key cs_stu_cno;

desc t_student;
-- 重新添加外键约束
alter table t_student add CONSTRAINT cs_stu_cno FOREIGN key (classno) REFERENCES t_class (cno) on UPDATE CASCADE on DELETE CASCADE;
-- 试试更新：
UPDATE t_class set cno = 5 where cno = 3;
-- 试试删除：
delete from t_class where cno =5;



-- 策略3: set null 置空操作：
-- 先删除之前的外键约束：
alter TABLE t_student drop FOREIGN key cs_stu_cno;
-- 重新添加外键约束：
alter table t_student add CONSTRAINT cs_stu_cno FOREIGN key (classno) REFERENCES t_class (cno) on UPDATE CASCADE on DELETE set null;

-- 试试更新：
UPDATE t_class set cno = 8 where cno =1;


-- 注意：
-- 1. 策略2 级联操作 和 策略2 的 删除操作可以混着使用：
alter table t_student add CONSTRAINT cs_stu_cno FOREIGN key (classno) REFERENCES t_class (cno) on UPDATE CASCADE on DELETE set null;


-- 2.应用场合：
-- (1)朋友圈删除，点赞。留言都删除。-- 级联操作
-- （2）解散班级 对应的学生置为null就可以了。-- set null


```



## DDL和DML的补充

【1】代码展示：

```sql
-- 创建数据库表：
CREATE TABLE t_student(
	sno int(6) auto_increment,
	sname VARCHAR(5) not null,
	sex char(1) DEFAULT '男',
	age int(3),
	enterdate date,
	classname varchar(10),
	email VARCHAR(17),
	CONSTRAINT pk_stu PRIMARY key (sno),  -- pk_stu主键约束的名字
	CONSTRAINT ck_stu_sex check (sex = '男' || sex = '女'),
	CONSTRAINT ck_stu_age check (age >= 18 and age <= 50),
	CONSTRAINT uq_stu_email UNIQUE (email)

);

-- 添加数据：
insert into t_student VALUES (1, '站三','男',21,'2022-1-1','java包','99@8.com');
-- > 1062 - Duplicate entry '23@8.com' for key 't_student.uq_stu_email'
-- > 3819 - Check constraint 'ck_stu_age' is violated.

insert into t_student VALUES (3, '站三','男',49,'2022-1-1','java包','113@8.com');
insert into t_student VALUES (6, '李三','男',22,'2022-1-1','java包','139@8.com');
insert into t_student VALUES (4, '王武','男',20,'2022-1-1','java包','239@8.com');

-- 查看学生表
SELECT * FROM t_student;

-- 添加一张表：快速添加：结构和数据跟t_student 都是一致的，
create table t_student2
AS
SELECT * FROM t_student;

SELECT * from t_student2;


-- 快速添加，结构跟t_student一致，数据没有：
CREATE table t_student3
AS
SELECT * from t_student where 1 = 2;

SELECT * FROM t_student3;


-- 快速添加， 结构跟 t_student 一致，数据没有：
create table t_student4
as 
SELECT sno,sname,age FROM t_student where 1 = 2;

select * FROM t_student4;


-- 删除数据操作: 清空数据
delete from t_student;
truncate table t_student2;
```



【2】delete和truncate注意：

从最终结果来看，虽然使用TRUNCATE操作和使用DELETE操作都可以删除表中的全部记录，但是两者还是有很多区别的，其区别主要体现在以下几个方面：

（1）DELETE为数据操作语言DML；TRUNCATE为数据定义语言DDL。

（2）DELETE操作是将表中所有记录一条一条直到删除完；TRUNCATE操作则是保留了表的结构，重新创建了这个表，所有的状态都相当于新表。

（3）DELETE操作可以回滚；TRUNCATE操作会导致隐式提交，因此不能回滚

（4）DELETE操作执行成功后返回已删除的行数（如删除4行记录，则会显示“Affected rows：4”）；截断操作不会返回已删除的行量，结果通常是“Affected rows：0”。DELETE操作删除表中记录后，再次向表中添加新纪录时，对于设置有自增约束字段的值会从删除前表中该字段的最大值加1开始自增；TRUNCATE操作则会重新从1开始自增。

## DQL查询操作

### 表的准备

准备四张表：dept（部门表），emp(员工表)，salgrade(薪资等级表)，bonus（奖金表）

```
-- 创建部门表
create table DEPT(
	DEPTNO int(2) not null,
	DNAME VARCHAR(14),
	LOC VARCHAR(13)

);

-- 给部门表中 DEPTNO 加一个主键约束
ALTER TABLE DEPT 
	ADD CONSTRAINT PK_DEPT PRIMARY KEY (DEPTNO);


-- 创建员工表
CREATE table EMP(
	EMPNO 		int(4) primary key,
	ENAME			VARCHAR(10),
	JOB			  VARCHAR(9),
	MGR				int(4),
	HIREDATE  DATE,
	SAL       double(7,2),
	COMM			double(7,2),
	DEPTNO    int(2)
);


-- 添加主表约束 ，
alter table EMP 
	add CONSTRAINT FK_DEPTNO foreign key(DEPTNO) 
	REFERENCES DEPT (DEPTNO);
	

-- 奖金等级表
create table SALGRADE
(
	GRADE int PRIMARY key,
	LOSAL double(7,2),
	HISAL double(7,2)
);



-- 奖金表
CREATE table BONUS
(
	ENAME VARCHAR(10),
	JOB VARCHAR(9),
	SAL  double(7,2),
	COMM double(7,2)
);


insert into DEPT (DEPTNO, DNAME, LOC)
values (10, 'ACCOUNTING', 'NEW YORK');
insert into DEPT (DEPTNO, DNAME, LOC)
values (20, 'RESEARCH', 'DALLAS');
insert into DEPT (DEPTNO, DNAME, LOC)
values (30, 'SALES', 'CHICAGO');
insert into DEPT (DEPTNO, DNAME, LOC)
values (40, 'OPERATIONS', 'BOSTON');



insert into EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES (7369, 'SMITH','CLERK',7902,'1980-12-17',800,NULL,20);
insert into EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES (7499, 'ALLEN','SALESMAN',7968,'1999-2-7',1600,300,20);
insert into EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES (7521, 'WARD','SALESMAN',7698,'1989-3-1',1200,500,30);
insert into EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES (7566, 'JONES','MANAGER',7839,'1956-12-17',2975,NULL,20);
insert into EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES (7654, 'MARTIN','SALESMAN',7698,'1910-6-17',2450,NULL,30);
insert into EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES (7698, 'BLAKE','MANAGER',7839,'1987-04-19',3000,NULL,30);
insert into EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES (7782, 'CLARK','MANAGER',7839,'1998-1-09',5000,NULL,10);
insert into EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES (7788, 'SCOTT','ANALYST',7566,'1997-5-7',6000,NULL,20);
insert into EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES (7839, 'KING','PRESIDENT',NULL,'1997-5-7',6000,NULL,10);
insert into EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES (7844, 'TURNER','SALESMANS',7698,'1997-5-7',6000,NULL,30);
insert into EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES (7876, 'ADAMS','CLERK',7788,'1997-5-7',6000,NULL,20);
insert into EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES (7900, 'JAMES','CLERK',7698,'1997-5-7',6000,NULL,30);
insert into EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES (7902, 'FORD','ANALYST',7566,'1997-5-7',6000,NULL,20);
insert into EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES (7934, 'MILLER','CLERK',7782,'1997-5-7',6000,NULL,10);


INSERT INTO SALGRADE (GRADE, LOSAL, HISAL)
VALUES (1,70,1200);
INSERT INTO SALGRADE (GRADE, LOSAL, HISAL)
VALUES (2,1343,4400);
INSERT INTO SALGRADE (GRADE, LOSAL, HISAL)
VALUES (3,450,4420);
INSERT INTO SALGRADE (GRADE, LOSAL, HISAL)
VALUES (4,2001,1230);
INSERT INTO SALGRADE (GRADE, LOSAL, HISAL)
VALUES (5,3001,9999);



-- 查看表：
SELECT * from dept;
-- 部门表： dept: department 部分， loc - location 位置


select * from emp;
-- 员工表： emp: employee 员工 ，mgr: manager:上级领导 , hiredate，入职日期  firedate 解雇日期,  common: 补贴
-- deptno  外键 参考 dept - deptno 字段
-- mgr 外键  参考 emp - empno 产生了自关联


-- 查看补贴额度
select * from salgrade;
-- hosal. -- lowsal
-- hisal -  highsal


--查看奖金表
select * from bonus;
```

### 单表查询

最简单的sql查询

```sql
-- 对emp查询：
SELECT * FROM EMP;  -- *代表所有数据
-- 显示部份列：
select EMPNO,ENAME,JOB FROM EMP;
-- 显示部分行： where 子句 
SELECT * FROM emp WHERE sal >5000;
-- 显示部分行。部分列 ：
select empno,ename,job,mgr FROM EMP where sal >5000;

-- 起别名：
select empno 员工编号, ename 姓名, sal 工资 from emp;
-- as alias  别名：
select empno as 员工编号, ename as 姓名, sal 工资 from emp;
select empno as '员工编号', ename as '姓名', sal as 工资 from emp;

-- 错误，有特色符号，必须加引号
select empno as 员工 编号， ename as "姓 名",sal as 工资 from emp;

-- 去重操作：
select job FROM emp;
SELECT DISTINCT job from emp;
select job, deptno FROM EMP;
select DISTINCT job, deptno FROM EMP;  -- 去除即包含 job, 又包含 deptno 的数据。


-- 排序 ：
select * from emp order by sal;  -- 默认情况下时按照升序排列的
select * from emp order by sal asc; -- asc 升序，可以默认不写
select * from emp order by sal desc; -- desc 降序，
select * from emp order by sal asc, deptno desc; -- 在工资升序的情况下，按照降序排列

```



### where子句

指定查询条件使用where子句，可以查询符合条件的部分记录。

```sql
-- 查看emp表：
select * from emp;


-- where子句，将过滤条件放在where子句的后面，可以筛选/过滤出我们想要的符合条件的数据。
-- where子句 + 关系运算符：
select * from emp where deptno = 10;
select * from emp where deptno > 10;
select * from emp where deptno >= 10;
select * from emp where deptno < 10;
select * from emp where deptno <= 10;
select * from emp where deptno <> 10;
select * from emp where deptno != 10;
select * from emp where job = 'CLERK';
select * from emp where job = 'clerk';   -- 默认情况下区分大小写；
select * from emp where hiredate  < '1995-10-12';

-- where子句 + 逻辑运算符：
select * from emp where sal > 1500 and sal < 3000;  -- (1500-3000)
select * from emp where sal > 1500 && sal < 3000;
select * from emp where sal > 1500 and sal < 3000 ORDER BY sal;
select * from emp where sal BETWEEN 1500 and 3000; -- [1500-3000]

-- where子句 + 逻辑运算符：
select * from emp where deptno = 10 or deptno = 20;
select * from emp where deptno = 10 || deptno = 20;
SELECT * FROM emp WHERE deptno in (10,20);
select * from emp where job in ('MANAGER','CLERK','ANALYST');


-- where 子句 + 模糊查询：
-- 查询名字中带有A的员工： -- % :代表任意多个字符
select * from emp where ename like '%A%';

-- - :任意一个字符
SELECT * FROM emp WHERE ename like '_A%';

-- 关于null的判断：
select * from emp where comm is null;
select * from emp where comm is not null;

-- 小括号的使用： 因为不同的运算级的优先级别不同，加括号是为了可读性，
select * from emp where job = 'SALESMAN' or job = 'CLERK' and sal >= 1500;
select * from emp where job = 'SALESMAN' or (job = 'CLERK' and sal >= 1500);
SELECT * from emp where (job = 'SALESMAN' or job = 'CLERK') and sal >= 1500;
```



### 使用函数

```sql
SQL中包含以下七种类型的函数：
一、聚合函数
聚合函数:返回汇总值 （它对其应用的每个行集返回一个值）
AVG(表达式) 返回表达式中所有的平均值。仅用于数字列并自动忽略NULL值。
COUNT(表达式) 返回表达式中非NULL值的数量。可用于数字和字符列。
COUNT(*) 返回表中的行数(包括有NULL值的列)。
MAX(表达式) 返回表达式中的最大值,忽略NULL值。可用于数字、字符和日期时间列。
MIN(表达式) 返回表达式中的最小值,忽略NULL值。可用于数字、字符和日期时间列。
SUM(表达式) 返回表达式中所有的总和,忽略NULL值。仅用于数字列。
二、转换函数
转型函数:将一种数据类型转换为另外一种（有CONVERT和CAST两种）
CONVERT(data_type[(length)], expression [, style])
例: Select convert(varchar(10) ,stuno) as stuno,stuname from student
CAST( expression AS data_type )
例: Select cast(stuno as varchar(10)) as stuno,stuname from student
Cast和Convert的区别
Cast 和Convert都是用来将一种数据类型的表达式转换为另一种数据类型的表达式。CAST 和 CONVERT 提供相似的功能，只是语法不同。在时间转化中一般用到convert,因为它比cast多加了一个style,可以转化成不同时间的格式。

三、日期函数
日期函数:处理日期和时间（由于不能直接执行算术函数,所以日期函数就十分有用）
GETDATE() 当前的系统日期。
例：select GETDATE() --结果：2020-10-19 15:34:27.343
DATEADD(日期部分,number,date) 返回带有指定数字(number)的日期(date),该数字添加到指定的日期部分(datepart)
例：elect DATEADD(dd, 5, getdate()) --增加5天时间
DATEDIFF(日期部分,date1,date2) 返回两个日期中指定的日期部分之间的差值
例：select DATEDIFF(mm, '2010-1-1', '2010-3-1 00:00:00') --结果：2
DATENAME(日期部分,date) 返回日期中日期部分的字符串形式
例：select DATENAME(dw,GETDATE()) --结果：星期二
DATEPART(日期部分,date) 返回日期中指定的日期部分的整数形式
例：select DATEPART(dw,GETDATE()) --结果(返回今天是一周中的第几天)：3
YEAR(date) 返回指定日期的年份数值
例：select YEAR(GETDATE()) --结果：2020
MONTH(date)返回指定日期的月份数值
DAY(date)返回指定日期的天数值
注：

DATENAME 和 DATEPART 的区别，返回的值类型不同，一个是VARCHAR一个是INT，另外就是星期会用本地语言来表示

当显示日期列的内容时如果只显示年月日部分,可以使用CONVERT转换函数对日期列进行转换

CONVERT(VARCHAR(10),日期字段名,120) --120 为日期格式YYYY-MM-DD

SELECT CONVERT(VARCHAR(10),盘点日期,120) AS 盘点日期 FROM 原材料盘点日期明细表

SQL中日期的表示方法及有效范围,如下:

日期部分	缩写	   值	       日期部分  	缩写	    值
 年	    yy	 1753-9999	       周	    wk	   1-53
 季度	    qq			1-4					小时			hh	  	0-23
	月	     mm			1-12					分钟		mi			0-59
一年中的天	dy			1-366					秒			ss			0-59
一月中的天	dd			1-31					毫秒		ms		0-999
一周中的天	dw				1-7			
四、数学函数
数学函数:执行算术运算（对数字值执行代数运算）
ABS(num_expr) 返回数值表达式的绝对值。

ACOS(float_expr) 返回角(以弧度表示),它的余弦值近似于指定的浮点表达式。

ASIN(float_expr) 返回角(以弧度表示),它的正弦值近似于指定的浮点表达式。

ATAN(float_expr) 返回角(以弧度表示),它的正切值近似于指定的浮点表达式。

ATN2(float_expr1, float_expr2) 返回角(以弧度表示),它的正切值在两个近似的浮点表达式之间。

CEILING(num_expr) 返回大于或等于数值表达式的最小整数。

COS(float_expr) 返回以浮点表达式表示的近似于指定角度(以弧度表示)的余弦三角函数的值。

COT(float_expr) 返回以浮点表达式表示的近似于指定角度(以弧度表示)的余切三角函数的值。

DEGREES(num_expr)返回数值表达式表示的弧度值对应的度值。

EXP(float_expr) 根据指定的近似浮点表达式,返回指数值。

FLOOR(num_expr) 返回小于或等于数值表达式的最大整数

LOG(float_expr) 根据指定的近似浮点表达式,返回自然对数值。

LOG10(float_expr) 根据指定的近似浮点表达式,返回以为底的对数。

PI() 返回常量值.141592653589793

POWER(num_expr,y) 返回幂为y的数值表达式的值。

RADIANS(num_expr) 返回数值表达式表示的度值对应的弧度值。

RAND([seed]) 随机返回的到之间的近似浮点值,可以对seed指定为整数表达式(可选)。

ROUND(num_expr,length) 对数值表达式截取指定的整数长度,返回四舍五入后的值。

SIGN(num_expr) 对正数执行+1操作,对负数和零执行-1操作。

SIN(float_expr) 返回以浮点表达式表示的近似于指定角度(以弧度表示)的正弦三角函数的值。

SQUARE(float_expr) 返回浮点表达式的平均值。

SQRT(float_expr) 返回指定的近似浮点表达式的平方根。

TAN(float_expr) 返回以浮点表达式表示的近似于指定角度(以弧度表示)的正切三角函数的值。

五、字符串函数
字符串函数:对字符串、二进制数据或表达式执行操作（可用于binary 和varbinary数据类型列,但主要用于char和varchar数据类型）
Expr1+expr2 返回两个表达式的组合形式的字符串。

ASCII(char_expr) 返回表达式最左边字符的ASCⅡ代码值。

CHAR(int_expr) 返回到之间的整数表达式的ASCⅡ字符值。如果输入的值不在有效范围内,则返回NULL。

CHARINDEX('pattern',char_expr) 返回字符表达式中指定模式的起始位置。

DIFFERENCE(char_expr1,char_expr2) 根据比较两个字符表达式的相似度,返回到之间的值。表示匹配度最佳。

LEN(char_expr) 返回字符表达式的长度。

LOWER(char_expr) 将字符表达式全部转换为小写。

LTRIM(char_expr) 返回删除掉前面空格的字符表达式。

PATINDEX('%pattern%',expr) 返回表达式中模式第一次出现的起始位置。返回表示不存在模式形式。

REPLICATE(char_expr,int_expr) 返回重复指定次数的字符表达式产生的字符串。

REVERSE(char_expr) 反转字符表达式。

RIGHT(char_expr,int_expr) 返回从字符表达式最右端起根据指定的字符个数得到的字符。

RTRIM(char_expr) 返回删除掉其后空格的字符表达式。

SOUNDEX(char_expr) 评估两个字符串的相似度后得到的位代码。

SPACE(int_expr) 返回包含指定空格数的字符串。

STR(float_expr[,length[,decimal]]) 返回浮点表达式的字符串表示法。

STUFF(char_expr1,start,length,char_expr2) 使用字符表达式替换字符表达式的一部分字符,从指定的位置开始替换指定的长度。

SUBSTRING(char_expr,start,length) 返回从字符表达式的指定位置开始,截取指定长度得到的字符集。

UPPER(char_expr) 将字符表达式全部转换为大写。

六、系统函数
系统函数:从数据库返回在SQLSERVER中的值、对象或设置的特殊信息（用于返回元数据或配置设置）
COALESCE(expr1,expr2, xprN) 返回第一个非NULL表达式。

COL_LENGTH('table_name','column_name') 返回列的长度。

COL_NAME(table_id,column_id) 返回指定的表中的列名。

DATALENGTH('expr') 返回任何数据类型的实际长度。

DB_ID([‘database_name']) 返回数据库的标识号。

DB_NAME([database_id]) 返回数据库的名称。

GETANSINULL([‘database_name']) 返回数据库的默认空性(Nullability)。

HOST_ID() 返回工作站的标识号。

HOST_NAME() 返回工作站的名称。

IDENT_INCR('table_or_view') 有新的记录添加入到表中时计数加。

IDENT_SEED('table_or_view') 返回标识列的起始编号。

INDEX_COL('table_name',index_id,key_id) 返回索引的列名。

ISNULL(expr,value) 使用指定的值替换的NULL表达式。

NULLIF(expr1,expr2) Expr1与Expr2相等时,返回Null。

OBJECT_ID('obj_name') 返回数据库对象标识号。

OBJECT_NAME('object_id') 返回数据库对象名。

STATS_DATE(table_id,index_id) 返回上次更新指定索引的统计的日期。

SUSER_SID([‘login_name']) 返回用户的登录标识号。

SUSER_ID([‘login_name']) 返回用户的登录标识号。这个函数类似于SUSER_SID()函数,并且保留了向后的兼容性。

SUSER_SNAME([server_user_id]) 返回用户的登录标识号。

SUSER_NAME([server_user_id]) 返回用户的登录标识号。这个函数类似于SUSER_SNAME()函数,并且保留了向后的兼容性。

USER_ID('user_name') 返回用户的数据库标识号。

USER_NAME(['user_id']) 返回用户的数据库名称。

七、文本和图像函数
文本和图像函数:对文本和图像数据执行操作（通常返回有关文本和图像数据所需的信息。文本和图像数据是以二进制格式的形式进行存储的）
TEXTPTR(col_name) 返回varbinary格式的文本指针值。对文本指针进行检查以确保它指向第一个文本页。

TEXTVALID('table_name.col_name',text_ptr)检查给定的文本指针是否有效。返回表示有效,返回表示指针无效。
```





一. 单行函数：可以理解为向函数传入一个参数，返回一个值。

单行函数是指对每一题记录输入值进行计算，并得到相应的计算结果，然后返回给用户，也就是说，每条记录作为一个输入参数，经过函数计算得到每条记录的计算结果。

二.多行函数：有多个输出结果，有多个输入。

多行函数是指对一组数据进行运算，针对这一组数据（多行记录）只返回一个结果，也称为分组函数。

#### 单行函数



```sql
-- 函数举例：
select empno,ename, lower(ename),UPPER(ename),sal from emp;
-- 函数的功能：封装了待定的一些功能，我们直接拿过来使用，
-- 函数作用： 为了提供select的能力
-- 注意：函数没有改变数据自身的值，而是在真实数据的上面进行处理，展示新的结果而已。


select max(sal),MIN(sal),COUNT(sal),SUM(sal),AVG(sal) from emp;
-- 函数的分类：
-- LOWER(ename), UPPER(ename) : 改变每一条结果，每一条数据。 -- 单行函数
-- max(sal),min(sal),count(sal),SUM(sal),AVG(sal). :多条数据，最终展示一个结果。-- 多行函数
```

除了多行函数（max,min.count,sum,avg），都是单行函数。

##### 1.字符串函数（String,StringBuilder）

| 函数                         | 描述                                                        |
| ---------------------------- | ----------------------------------------------------------- |
| UPPER(char_expr)             | 将字符表达式全部转换为大写。                                |
| INSERT(str,index,n,newstr)   | 将字符串str从第index位置开始的n个字符替换成字符串str        |
| LENGTH(str)                  | 获取字符串str的长度                                         |
| LOWER()                      | 将字符串str中的每个字符转换为小写                           |
| CONCAT(str1, str2, … , strn) | 将str1,str2….,strn ,拼接成一个字符串                        |
| LEFT(str, n)                 | 获取字符串str最左边的n个字符                                |
| RIGHT(str, n)                | 获取字符串str最右边的n个字符                                |
| LPAD(str, n, pad)            | 使用字符串pad在str的最左边进行填充，直到长度为n个字符为止。 |
| RPAD(str, n, pad)            | 使用字符串pad在str的最右边进行填充，直到长度为n个字符为止。 |
| LTRIM（str）                 | 去除字符串str左侧的空格                                     |



##### 2.数值函数(Math)

| 函数                      | 描述                                       |
| ------------------------- | ------------------------------------------ |
| ABS(num)                  | 返回num的绝对值                            |
| CEIL(num)                 | 返回大于num的最大整数（向上取整）          |
| FLOOR(num)                | 返回小于num的最大整数（向下取整）          |
| MOD(num1, num2)           | 返回num1/num2的余数（取模）                |
| PI()                      | 返回圆周率的值                             |
| POW(num, n)/POWER(num, n) | 返回num的n次方                             |
| RAND(num)                 | 返回0～1之间的随机数                       |
| ROUND(num, n)             | 返回x四舍五入后的值，该值保留到小数点后n位 |
| TRUNCATE(num, n)          | 返回num被舍去至小数点后n位的值             |

##### 3.日期和时间函数

| 函数                                                         | 描述                                       |
| ------------------------------------------------------------ | ------------------------------------------ |
| CURDATE()                                                    | 返回当前日期                               |
| CURTIME()                                                    | 返回当前时间                               |
| NOW()                                                        | 返回当前日期和时间                         |
| SYSDATE()                                                    | 返回该函数执行时 的日期和时间              |
| DAYOFYEAR(date)                                              | 返回日期date为一年中的第几天               |
| WEKK(date)/WEEKOFYEAR(date)                                  | 返回日期date为一年中的第几周               |
| DATE_FORMAT(date, format)                                    | 返回该字符串format格式化后的日期date       |
| DATE_ADD(date, INTERVAL expo unit)/ ADDDATE(date, INTERVAL expr unit) | 返回date加上一个时间间隔后的新时间值       |
| DATE_SUB(date, INTERVAL expo unit)/ SUBDATE(date, INTERVAL expo unit) | 返回date减去一个时间间隔后的新时间值       |
| DATEDIFF(date1, date2)                                       | 返回起始日期date1与结束日期2之间的间隔天数 |



##### 4.流程函数（IF SWITCH）

| 间隔函数                                                     | 描述                                                       |
| ------------------------------------------------------------ | ---------------------------------------------------------- |
| IF(condition, t, f)                                          | 如果条件condition为真，则返回t，否则返回f                  |
| IFNULL(value1, value2)                                       | 如果value1不为null，则返回value1，否则返回value2           |
| NULLIF(value1, value2)                                       | 如果value1等于value2，则返回null，否则返回value1           |
| CASE value WHEN [value1] THEN result1 [WHEN [value2] THEN result2 …] [ELSE result] END | 如果value等于value1，则返回result1，。。，否则返回result   |
| CASE WHEN [condition1] THEN result1 [WHEN [condition2] THEN result2 …] [ELSE result] END | 如果条件condition为真，则返回result1，。。，否则返回result |

```sql
-- 单行函数包含：
-- 1.字符串函数：
select ename,LENGTH(ename),substring(ename,2,1) FROM emp;
-- subtring 字符串截取，2，从字符串下标2开始， 1: 截取一个长度 
-- 2. 数值函数：
SELECT ABS(-5),CEIL(5.3),FLOOR(5.9),ROUND(3.14) FROM dual;  -- dual 实际就是一个伪表
SELECT ABS(-5) 绝对值,CEIL(5.3) 向上取整,FLOOR(5.9)向下取整,ROUND(3.14)四舍五入;  -- 如果没有where语句的话，from dual 可以省略不写。
SELECT ceil(sal) from emp;
SELECT 10/3, 10%3, MOD(10,3);
-- 3. 日期与时间函数：
SELECT * FROM emp;
SELECT CURDATE(),CURTIME();  -- CURDATE() 年 月 日 CURTIME() 时分秒
SELECT NOW(),SYSDATE(),SLEEP(3),NOW(),SYSDATE() from dual; -- NOW(),SYSDATE(): 年月日时分秒

insert into emp VALUES (9999,'lili','SALASMEN',7698,NOW(),1000,null,30);
-- NOW()可以表示年月日时分秒，但是插入数据的时候还是要参照表的结构的
desc emp;
```



##### 5.JSON函数



##### 6.其他函数

| 函数               | 描述                                   |
| ------------------ | -------------------------------------- |
| DATABASE()         | 返回当前数据库名                       |
| VERSION()          | 返回当前Mysql的版本号                  |
| USER()             | 返回当前登录的用户名                   |
| INET_ATON(IP)      | 返回IP地址的数字表示                   |
| INET_NTOA          | 返回数字代表的IP地址                   |
| PASSWORD(str)      | 实现对字符串str的加密操作              |
| FORMAT(num, n)     | 实现对数字num的格式化操作，保留n位小数 |
| CONVERT(data, ype) | 实现对数据data转换成为type类型的操作   |



```sql
-- 4.流程函数
-- if 相关
select empno,ename,sal,if(sal>=2500,'高薪','低薪') as '薪资等级' from emp;  -- if- else 双分支结构
select empno,ename,sal,comm,sal+IFNULL(comm,0)FROM emp;  -- 如果comm是null, 那么取值为0， -- 单分支
SELECT NULLIF(1,1), NULLIF(1,2) from dual;  -- 如果value1 等于 value2 ，则返回null，否则返回 value1.

-- case相关
select empno,ename,job from emp;
-- case 等值判断
SELECT empno,ename,job,
case job
	when 'CLERK' then '店员'
	when 'SALESMAN' then '销售'
	when 'MANAGER' then '经理'
	else '其他'
	end '岗位',
	sal FROM emp;
	
-- case 区间判断：
select empno, ename,sal,
case 
	when sal <= 1000 then 'A'
	when sal <= 2000 then 'B'
	when sal <= 3000 then 'C'
	else 'D'
	end '工资等级',
	deptno from emp;

-- 5.JSON函数
-- 6.其他函数
select database(), user(), VERSION() from dual;


```



#### 多行函数

对一组数据进行运算，针对一组数据（多行记录）值返回一个结果，也称为分组函数。

多行函数包含：

| 函数    | 描述                   |
| ------- | :--------------------- |
| COUNT() | 统计表中记录的数目     |
| SUM()   | 计算指定字段值的总和   |
| AVG()   | 计算指定字段值的平均值 |
| MAX()   | 统计指定字段值的最大值 |
| MIN()   | 统计指定字段值的最小值 |

```sql
-- 多行函数：
select MAX(sal),MIN(sal),COUNT(sal),SUM(sal),SUM(sal)/COUNT(sal),AVG(sal) from emp;
select * from emp;
-- 多行函数自动忽略null值：
select MAX(comm),MIN(comm),COUNT(comm),SUM(comm),SUM(comm)/COUNT(comm),AVG(comm) from emp;

-- max(), min(), count()针对所有类型， sum(),avg() 只针对数值型类型有效
select MAX(ename),MIN(ename),COUNT(ename),SUM(ename),SUM(ename)/COUNT(ename),AVG(ename) from emp;


-- count -- 计数
-- 统计表的记录数：方式1
SELECT * from emp;
select count(comm) from emp;
SELECT count(*) from emp;

-- 统计表的记录数：方式2
select 1 from dual;
select 1 from emp;
select count(1) from emp;
```



### Group by分组

【1】group by:用来进行分组

【2】sql展示：

```sql
select * from emp;
-- 统计各个部门的平均工资：
select deptno, avg(sal) from emp; -- 字段和多行函数不可以同时使用
select deptno, avg(sal) from emp GROUP BY DEPTNO; -- 字段和多行函数不可以同时使用，除非这个字段属于分组。
select deptno, avg(sal) from emp GROUP BY deptno order by deptno desc;

-- 统计各个岗位的平均工资：
SELECT avg(sal) from emp group by job;
SELECT job,LOWER(job), avg(sal) from emp group by job;
```



### having分组后筛选

代码：

```sql
-- 统计各个部门的平均工资，只显示平均工资2000以上， - 分组以后进行二次筛选  HAVING
select DEPTNO,avg(sal) from emp GROUP BY deptno having avg(sal) > 2000
select DEPTNO,avg(sal) 平均工资 from emp GROUP BY deptno having 平均工资 > 2000
select DEPTNO,avg(sal) 平均工资 from emp GROUP BY deptno having 平均工资 > 2000 order by deptno desc;

-- 统计各个岗位的平均工资，除了MANAGER
-- 方法1:
select job,AVG(sal) from emp where job != 'MANAGER' GROUP BY job ORDER BY job desc;
-- 方法2:
select job,AVG(sal) from emp GROUP BY job having job != 'MANAGER';
```



### 单表查询总结

【1】select语句总结

select column, group_function(column)

From table

[where condition]

[group by group_by_expression]

[having group_codition]

[order by column]

注意：顺序固定，不可以改变顺序



【2】select语句的执行顺序

From - where - group by - select - having  - order by



【3】单表查询练习：

```sql
-- 单表查询练习：

select * from emp;
-- 列出工资最小值小于2000的职位：
select job,min(sal)
from emp
group by job
having min(sal) < 2000

-- 列出平均工资大于1200元的部门和工作搭配组合：
select deptno,job,avg(sal)
from emp
GROUP BY deptno,job
having AVG(sal) > 1200

-- 统计【人数小于4】部门的平均工资：
SELECT DEPTNO,COUNT(1),AVG(SAL)
FROM EMP
group by deptno
having count(1) < 4

-- 统计各部门的最高工资，排除最高工资小于3000的部门：
select deptno,max(sal)
from EMP
group by deptno
having max(sal) > 3000
```



### 多表查询

【1】内连接引入：

实际开发中往往需要针对两张甚至更多张数据表进行操作，而这多张表之间需要使用主键和外键关联在一起，然后使用连接查询来查询多张表中满足要求的数据记录。

一条SQL语句查询多个表，得到一个结果，包含多个表的数据，效率高，在SQL99中，连接查询需要使用join关键字实现。

提供了多种连接查询的类型：class natural using on

交叉连接（Cross Join），又称“笛卡尔连接（Cartesian Join）”或“叉乘（Product）”，它是所有类型的内连接的基础。 如果把表视为行记录的集合，那么交叉连接即返回这两个集合的笛卡尔积，返回到结果集合中的数据行数等于第一张表中符合查询条件的数据行数乘以第二个表中符合查询条件的数据行数。



![image-20221112134224852](/Users/rain/Library/Application Support/typora-user-images/image-20221112134224852.png)

【2】sql展示：

